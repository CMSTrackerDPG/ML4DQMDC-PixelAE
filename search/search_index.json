{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Some utilities and example notebooks for ML4DQM/DC This repository contains example code for the ML4DQM/DC project. It was developed with the idea of training autoencoders on the per-lumisection histograms stored in dedicated DQMIO files in order to (partially) automate the DQM and/or DC process. However, it is intended to be generally useful for any ML4DQM/DC study (i.e. any subsystem, any type of histogram, any classification method). In more detail: The framework has been developed based on a number of 1D histograms related to the status of the pixel tracker. Support for 2D histograms was added later and tested preliminarily, but some parts of the code may not yet support them. Please feel free to contact me if you notice a place in the code where this is the case. Likewise, most of the development effort went into using an autoencoder as classification algorithm, i.e. looking at the mean-squared-difference between a histogram and its reconstruction as a measure for anomality. Support for other algorithms is also present, one just needs to define a class deriving from src/classifiers/HistogramClassifier. Working examples for NMF, PCA and a couple of other classifiers are present in the tutorials. Structure of this repository: There are five important directories: tutorials, utils, src, run and omsapi. The other directories in the repository contain either data or meta-information (e.g. for documentation). In more detail: utils: contains a number of python notebooks and equivalent scripts with static utility functions for general use. They are being called and used in various places throughout the code. src: contains the classes for this repository: DataLoader: class for convenient loading of histograms from the input csv files. HistStruct: a histogram container for easy handling of multiple types of histograms simultaneously and consistently. classifiers: folder containing an abstract base HistogramClassifier class and derived classes representing concrete examples of histogram classification algorithms. cloudfitters: folder containing an abstract base CloudFitter class and derived classes representing concrete examples of point cloud fitting algorithms (used when working with multiple types of histograms simultaneously). tutorials: contains a number of notebooks that can be used to get familiar with the code and its capabilities. run: contains code for alternative ways of running the workflow, e.g. with configuration files or with a GUI. Note: under development, recommended to start with script-based workflows first (as exemplified in the tutorials). omsapi: standalone API for retrieving information from OMS. Tutorials: Some tutorials are located in the tutorials folder in this repository, that should help you get started with the code. They can be grouped into different steps: Step 1: put the data in a more manageable format. The raw csv files that are our common input are not very easy to work with. Therefore you would probably first want to do something similar to what's done in the notebook read_and_write_data.ipynb. See the code and inline comments in that script and the functions it refers to for more detailed explanation. Its output is one single csv file per histogram type and per year, which is often much more convenient than the original csv files (which contain all histogram types together and are split per number of lines, not per run). All other functions and notebooks presuppose this first step. Step 2: plot the data. Next, you can run plot_histograms.ipynb and plot_histograms_loop.ipynb. These notebooks should help you get a feeling of what your histogram looks like in general, and perhaps help you find some anomalies that you can use for testing. For 2D histograms, look at plot_histograms_2d.ipynb instead. Step 3: train an autoencoder. The scripts autoencoder.ipynb and autoencoder_iterative.ipynb are used to train an autoencoder on the whole dataset or a particular subset respectively. Finally, autoencoder_combine.ipynb trains autoencoders on multiple types of histograms and combines the mse's for each. An example on how to implement another classification method is shown in template_combine.ipynb. Other remarks: The repository contains no data files. I was planning to put some example data files in a data folder, but the files are too big for github. However, the tutorial read_and_write_data.ipynb should help you get the data from where it is stored and put it in a useful format for further processing. Another way to get started is to get them from my CERNBox Disclaimer: the whole repository is still in development stage. Feel free to contact me in case you found bugs or if you have other suggestions. To get the tutorial notebooks running in SWAN (preferred method): Log in to SWAN. Go to Projects. Click the cloud icon that says 'Download Project from git' Paste the following url: https://github.com/LukaLambrecht/ML4DQM-DC.git . (alternative method): Log in to SWAN. Click on the leftmost icon on the top right ('new terminal'). Navigate to where you want this repository (the starting place is your CERNBox home directory). Paste this command: git clone https://github.com/LukaLambrecht/ML4DQM-DC.git (or however you usually clone a repository). Exit the terminal. The folder should now be where you cloned it, and you can open and run the notebooks in it in SWAN. Further documentation: Documentation for all the class definitions and functions in the relevant code directories: https://LukaLambrecht.github.io/ML4DQM-DC/ (note: this documentation is generated automatically from comments in the code and currently not yet in perfect shape, both regarding content and layout). Note that the website above does not include documentation for the tutorials (yet?). However, some comments in the tutorial notebooks should provide (enough?) explanation to follow along.","title":"Home"},{"location":"#some-utilities-and-example-notebooks-for-ml4dqmdc","text":"This repository contains example code for the ML4DQM/DC project. It was developed with the idea of training autoencoders on the per-lumisection histograms stored in dedicated DQMIO files in order to (partially) automate the DQM and/or DC process. However, it is intended to be generally useful for any ML4DQM/DC study (i.e. any subsystem, any type of histogram, any classification method). In more detail: The framework has been developed based on a number of 1D histograms related to the status of the pixel tracker. Support for 2D histograms was added later and tested preliminarily, but some parts of the code may not yet support them. Please feel free to contact me if you notice a place in the code where this is the case. Likewise, most of the development effort went into using an autoencoder as classification algorithm, i.e. looking at the mean-squared-difference between a histogram and its reconstruction as a measure for anomality. Support for other algorithms is also present, one just needs to define a class deriving from src/classifiers/HistogramClassifier. Working examples for NMF, PCA and a couple of other classifiers are present in the tutorials.","title":"Some utilities and example notebooks for ML4DQM/DC"},{"location":"#structure-of-this-repository","text":"There are five important directories: tutorials, utils, src, run and omsapi. The other directories in the repository contain either data or meta-information (e.g. for documentation). In more detail: utils: contains a number of python notebooks and equivalent scripts with static utility functions for general use. They are being called and used in various places throughout the code. src: contains the classes for this repository: DataLoader: class for convenient loading of histograms from the input csv files. HistStruct: a histogram container for easy handling of multiple types of histograms simultaneously and consistently. classifiers: folder containing an abstract base HistogramClassifier class and derived classes representing concrete examples of histogram classification algorithms. cloudfitters: folder containing an abstract base CloudFitter class and derived classes representing concrete examples of point cloud fitting algorithms (used when working with multiple types of histograms simultaneously). tutorials: contains a number of notebooks that can be used to get familiar with the code and its capabilities. run: contains code for alternative ways of running the workflow, e.g. with configuration files or with a GUI. Note: under development, recommended to start with script-based workflows first (as exemplified in the tutorials). omsapi: standalone API for retrieving information from OMS.","title":"Structure of this repository:"},{"location":"#tutorials","text":"Some tutorials are located in the tutorials folder in this repository, that should help you get started with the code. They can be grouped into different steps: Step 1: put the data in a more manageable format. The raw csv files that are our common input are not very easy to work with. Therefore you would probably first want to do something similar to what's done in the notebook read_and_write_data.ipynb. See the code and inline comments in that script and the functions it refers to for more detailed explanation. Its output is one single csv file per histogram type and per year, which is often much more convenient than the original csv files (which contain all histogram types together and are split per number of lines, not per run). All other functions and notebooks presuppose this first step. Step 2: plot the data. Next, you can run plot_histograms.ipynb and plot_histograms_loop.ipynb. These notebooks should help you get a feeling of what your histogram looks like in general, and perhaps help you find some anomalies that you can use for testing. For 2D histograms, look at plot_histograms_2d.ipynb instead. Step 3: train an autoencoder. The scripts autoencoder.ipynb and autoencoder_iterative.ipynb are used to train an autoencoder on the whole dataset or a particular subset respectively. Finally, autoencoder_combine.ipynb trains autoencoders on multiple types of histograms and combines the mse's for each. An example on how to implement another classification method is shown in template_combine.ipynb.","title":"Tutorials:"},{"location":"#other-remarks","text":"The repository contains no data files. I was planning to put some example data files in a data folder, but the files are too big for github. However, the tutorial read_and_write_data.ipynb should help you get the data from where it is stored and put it in a useful format for further processing. Another way to get started is to get them from my CERNBox Disclaimer: the whole repository is still in development stage. Feel free to contact me in case you found bugs or if you have other suggestions.","title":"Other remarks:"},{"location":"#to-get-the-tutorial-notebooks-running-in-swan","text":"","title":"To get the tutorial notebooks running in SWAN"},{"location":"#preferred-method","text":"Log in to SWAN. Go to Projects. Click the cloud icon that says 'Download Project from git' Paste the following url: https://github.com/LukaLambrecht/ML4DQM-DC.git .","title":"(preferred method):"},{"location":"#alternative-method","text":"Log in to SWAN. Click on the leftmost icon on the top right ('new terminal'). Navigate to where you want this repository (the starting place is your CERNBox home directory). Paste this command: git clone https://github.com/LukaLambrecht/ML4DQM-DC.git (or however you usually clone a repository). Exit the terminal. The folder should now be where you cloned it, and you can open and run the notebooks in it in SWAN.","title":"(alternative method):"},{"location":"#further-documentation","text":"Documentation for all the class definitions and functions in the relevant code directories: https://LukaLambrecht.github.io/ML4DQM-DC/ (note: this documentation is generated automatically from comments in the code and currently not yet in perfect shape, both regarding content and layout). Note that the website above does not include documentation for the tutorials (yet?). However, some comments in the tutorial notebooks should provide (enough?) explanation to follow along.","title":"Further documentation:"},{"location":"omsapi/","text":"OMS API: retrieve information from the OMS database Collection of tools for obtaining OMS information in json-like format. Note: this functionality supersedes the older version in the omsinterface folder! References: The code is based on the oms api repository here: https://gitlab.cern.ch/cmsoms/oms-api-client . The file omsapi.py in this folder is a direct copy of the omsapi/__init__.py file in that repository, as recommended by the developers to get it running on SWAN. See also these slides for further info on the setup of the app and this site for the available endpoints. How to use: You will need to authenticate through an application registered with the OMS developer team. Either contact me on llambrec@cern.ch so I can send you my application ID and client secret, or create your own as explained below. Open example.ipynb for some examples. You need to import get_oms_api.py, then create an OMSAPI instance via get_oms_api() (only once, can be re-used for multiple queries) and then query the information via get_oms_data( \\<arguments> ). See example.ipynb or get_oms_data.py for details. How to create a personal application for authentication: You will need to register a personal application ID and client secret with the OMS developer team. See the slides linked above on how to do that (only slide 4-6 are relevant, the rest has been taken care of). You will receive an application ID and client secret (both are just string-like variables). Create a new python file in this folder called clientid.py and define two variables in there: API_CLIENT_ID = '\\<your application ID>' API_CLIENT_SECRET = '\\<your client secret>' That should be all!","title":"README"},{"location":"omsapi/get_oms_data/","text":"get oms data Functionality to call the OMS API with the correct query based on input parameters How to use? Check the readme file in this directory for the required setup! In particular, you will need an application ID and client secret to authenticate. Once this is ready, you can do the following: - Import this module, for example via \"from get_oms_data import get_oms_api, get_oms_data, get_oms_response_attribute\" - Create an instance of the OMS API class using \"omsapi = get_oms_api()\" This instance can be re-used for all consecutive calls to OMS, no need to recreate it for every call. - Make a call to \"get_oms_data\", where the first argument is the instance you just created. Other arguments: see the function documentation below. - The returned object is a complicated dictionary containing all information. Simply print it to find out its exact structure and how to access exactly the values you need. The function \"get_oms_response_attribute\" is a small helper function to retrieve a specific attribute from this dictionary. See the notebook example.ipynb in this directory for some examples! get_oms_api full signature: def get_oms_api() comments: get an OMSAPI instance takes no input arguments, as the configuration parameters are unlikely to change very often if needed, these parameters can be changed in the file urls.py get_oms_data full signature: def get_oms_data( omsapi, api_endpoint, runnb, extrafilters=[], extraargs={}, sort=None, attributes=[], limit_entries=1000) comments: query some data from OMS input arguments: - omsapi: an OMSAPI instance, e.g. created by get_oms_api() - api_endpoint: string, target information, e.g. 'runs' or 'lumisections' (see the readme for a link where the available endpoints are listed) - runnb: run number(s) to retrieve the info for, either integer (for single run) or tuple or list of two elements (first run and last run) (can also be None to not filter on run number but this is not recommended) - extrafilters: list of extra filters (apart from run number), each filter is supposed to be a dict of the form {'attribute_name':<name>,'value':<value>,'operator':<operator>} where <name> must be a valid field name in the OMS data, <value> its value, and <operator> chosen from \"EQ\", \"NEQ\", \"LT\", \"GT\", \"LE\", \"GE\" or \"LIKE\" - extraargs: dict of custom key/value pairs to add to the query (still experimental, potentially usable for changing the granularity from 'run' to 'lumisection' for e.g. L1 trigger rates, see example.ipynb) - sort: valid field name in the OMS data by which to sort - attributes: list of valid field names in the OMS data to return (if not specified, all information is returned) - limit_entries: entry limit for output json object get_oms_response_attribute full signature: def get_oms_response_attribute( omsresponse, attribute ) comments: small helper function to retrieve a list of values for a single attribute input arguments: - omsresponse: the json-like object returned by get_oms_data - attribute: name of one of the attributes present in omsresponse","title":"get_oms_data"},{"location":"omsapi/get_oms_data/#get-oms-data","text":"Functionality to call the OMS API with the correct query based on input parameters How to use? Check the readme file in this directory for the required setup! In particular, you will need an application ID and client secret to authenticate. Once this is ready, you can do the following: - Import this module, for example via \"from get_oms_data import get_oms_api, get_oms_data, get_oms_response_attribute\" - Create an instance of the OMS API class using \"omsapi = get_oms_api()\" This instance can be re-used for all consecutive calls to OMS, no need to recreate it for every call. - Make a call to \"get_oms_data\", where the first argument is the instance you just created. Other arguments: see the function documentation below. - The returned object is a complicated dictionary containing all information. Simply print it to find out its exact structure and how to access exactly the values you need. The function \"get_oms_response_attribute\" is a small helper function to retrieve a specific attribute from this dictionary. See the notebook example.ipynb in this directory for some examples!","title":"get oms data"},{"location":"omsapi/get_oms_data/#get95oms95api","text":"full signature: def get_oms_api() comments: get an OMSAPI instance takes no input arguments, as the configuration parameters are unlikely to change very often if needed, these parameters can be changed in the file urls.py","title":"get_oms_api"},{"location":"omsapi/get_oms_data/#get95oms95data","text":"full signature: def get_oms_data( omsapi, api_endpoint, runnb, extrafilters=[], extraargs={}, sort=None, attributes=[], limit_entries=1000) comments: query some data from OMS input arguments: - omsapi: an OMSAPI instance, e.g. created by get_oms_api() - api_endpoint: string, target information, e.g. 'runs' or 'lumisections' (see the readme for a link where the available endpoints are listed) - runnb: run number(s) to retrieve the info for, either integer (for single run) or tuple or list of two elements (first run and last run) (can also be None to not filter on run number but this is not recommended) - extrafilters: list of extra filters (apart from run number), each filter is supposed to be a dict of the form {'attribute_name':<name>,'value':<value>,'operator':<operator>} where <name> must be a valid field name in the OMS data, <value> its value, and <operator> chosen from \"EQ\", \"NEQ\", \"LT\", \"GT\", \"LE\", \"GE\" or \"LIKE\" - extraargs: dict of custom key/value pairs to add to the query (still experimental, potentially usable for changing the granularity from 'run' to 'lumisection' for e.g. L1 trigger rates, see example.ipynb) - sort: valid field name in the OMS data by which to sort - attributes: list of valid field names in the OMS data to return (if not specified, all information is returned) - limit_entries: entry limit for output json object","title":"get_oms_data"},{"location":"omsapi/get_oms_data/#get95oms95response95attribute","text":"full signature: def get_oms_response_attribute( omsresponse, attribute ) comments: small helper function to retrieve a list of values for a single attribute input arguments: - omsresponse: the json-like object returned by get_oms_data - attribute: name of one of the attributes present in omsresponse","title":"get_oms_response_attribute"},{"location":"omsapi/omsapi/","text":"omsapi [class] OMSApiException comments: (no valid documentation found) [class] OMSQuery comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, base_url, resource, verbose, cookies, oms_auth, cert_verify, retry_on_err_sec, proxies) comments: (no valid documentation found) \u2937 _attr_exists full signature: def _attr_exists(self, attr) comments: (no valid documentation found) \u2937 _load_meta full signature: def _load_meta(self) comments: (no valid documentation found) \u2937 _warn full signature: def _warn(self, message, raise_exc=False) comments: (no valid documentation found) \u2937 set_verbose full signature: def set_verbose(self, verbose) comments: (no valid documentation found) \u2937 set_validation full signature: def set_validation(self, attribute_validation) comments: (no valid documentation found) \u2937 attrs full signature: def attrs(self, attributes=None) comments: (no valid documentation found) \u2937 filters full signature: def filters(self, filters) comments: (no valid documentation found) \u2937 filter full signature: def filter(self, attribute, value, operator=\"EQ\") comments: (no valid documentation found) \u2937 clear_filter full signature: def clear_filter(self) comments: (no valid documentation found) \u2937 sort full signature: def sort(self, attribute, asc=True) comments: (no valid documentation found) \u2937 paginate full signature: def paginate(self, page=1, per_page=10) comments: (no valid documentation found) \u2937 include full signature: def include(self, key) comments: (no valid documentation found) \u2937 custom full signature: def custom(self, key, value=None) comments: (no valid documentation found) \u2937 data_query full signature: def data_query(self) comments: (no valid documentation found) \u2937 data full signature: def data(self) comments: (no valid documentation found) \u2937 meta full signature: def meta(self) comments: (no valid documentation found) \u2937 get_request full signature: def get_request(self, url, verify=False) comments: (no valid documentation found) [class] OMSAPIOAuth comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, client_id, client_secret, audience=\"cmsoms-prod\", cert_verify=True, proxies={}, retry_on_err_sec=0) comments: (no valid documentation found) \u2937 auth_oidc full signature: def auth_oidc(self) comments: (no valid documentation found) \u2937 auth_oidc_req full signature: def auth_oidc_req(self) comments: (no valid documentation found) [class] OMSAPI comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, api_url=\"https://cmsoms.cern.ch/agg/api\", api_version=\"v1\", verbose=True, cert_verify=True, retry_on_err_sec=0, proxies={}) comments: (no valid documentation found) \u2937 query full signature: def query(self, resource, query_validation=True) comments: (no valid documentation found) \u2937 auth_oidc full signature: def auth_oidc(self, client_id, client_secret, audience=\"cmsoms-prod\", proxies={}) comments: (no valid documentation found) \u2937 auth_krb full signature: def auth_krb(self, cookie_path=\"ssocookies.txt\") comments: (no valid documentation found) rm_file full signature: def rm_file(filename) comments: (no valid documentation found)","title":"omsapi"},{"location":"omsapi/omsapi/#omsapi","text":"","title":"omsapi"},{"location":"omsapi/omsapi/#class-omsapiexception","text":"comments: (no valid documentation found)","title":"[class] OMSApiException"},{"location":"omsapi/omsapi/#class-omsquery","text":"comments: (no valid documentation found)","title":"[class] OMSQuery"},{"location":"omsapi/omsapi/#9595init9595","text":"full signature: def __init__(self, base_url, resource, verbose, cookies, oms_auth, cert_verify, retry_on_err_sec, proxies) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"omsapi/omsapi/#95attr95exists","text":"full signature: def _attr_exists(self, attr) comments: (no valid documentation found)","title":"&#10551; _attr_exists"},{"location":"omsapi/omsapi/#95load95meta","text":"full signature: def _load_meta(self) comments: (no valid documentation found)","title":"&#10551; _load_meta"},{"location":"omsapi/omsapi/#95warn","text":"full signature: def _warn(self, message, raise_exc=False) comments: (no valid documentation found)","title":"&#10551; _warn"},{"location":"omsapi/omsapi/#set95verbose","text":"full signature: def set_verbose(self, verbose) comments: (no valid documentation found)","title":"&#10551; set_verbose"},{"location":"omsapi/omsapi/#set95validation","text":"full signature: def set_validation(self, attribute_validation) comments: (no valid documentation found)","title":"&#10551; set_validation"},{"location":"omsapi/omsapi/#attrs","text":"full signature: def attrs(self, attributes=None) comments: (no valid documentation found)","title":"&#10551; attrs"},{"location":"omsapi/omsapi/#filters","text":"full signature: def filters(self, filters) comments: (no valid documentation found)","title":"&#10551; filters"},{"location":"omsapi/omsapi/#filter","text":"full signature: def filter(self, attribute, value, operator=\"EQ\") comments: (no valid documentation found)","title":"&#10551; filter"},{"location":"omsapi/omsapi/#clear95filter","text":"full signature: def clear_filter(self) comments: (no valid documentation found)","title":"&#10551; clear_filter"},{"location":"omsapi/omsapi/#sort","text":"full signature: def sort(self, attribute, asc=True) comments: (no valid documentation found)","title":"&#10551; sort"},{"location":"omsapi/omsapi/#paginate","text":"full signature: def paginate(self, page=1, per_page=10) comments: (no valid documentation found)","title":"&#10551; paginate"},{"location":"omsapi/omsapi/#include","text":"full signature: def include(self, key) comments: (no valid documentation found)","title":"&#10551; include"},{"location":"omsapi/omsapi/#custom","text":"full signature: def custom(self, key, value=None) comments: (no valid documentation found)","title":"&#10551; custom"},{"location":"omsapi/omsapi/#data95query","text":"full signature: def data_query(self) comments: (no valid documentation found)","title":"&#10551; data_query"},{"location":"omsapi/omsapi/#data","text":"full signature: def data(self) comments: (no valid documentation found)","title":"&#10551; data"},{"location":"omsapi/omsapi/#meta","text":"full signature: def meta(self) comments: (no valid documentation found)","title":"&#10551; meta"},{"location":"omsapi/omsapi/#get95request","text":"full signature: def get_request(self, url, verify=False) comments: (no valid documentation found)","title":"&#10551; get_request"},{"location":"omsapi/omsapi/#class-omsapioauth","text":"comments: (no valid documentation found)","title":"[class] OMSAPIOAuth"},{"location":"omsapi/omsapi/#9595init9595_1","text":"full signature: def __init__(self, client_id, client_secret, audience=\"cmsoms-prod\", cert_verify=True, proxies={}, retry_on_err_sec=0) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"omsapi/omsapi/#auth95oidc","text":"full signature: def auth_oidc(self) comments: (no valid documentation found)","title":"&#10551; auth_oidc"},{"location":"omsapi/omsapi/#auth95oidc95req","text":"full signature: def auth_oidc_req(self) comments: (no valid documentation found)","title":"&#10551; auth_oidc_req"},{"location":"omsapi/omsapi/#class-omsapi","text":"comments: (no valid documentation found)","title":"[class] OMSAPI"},{"location":"omsapi/omsapi/#9595init9595_2","text":"full signature: def __init__(self, api_url=\"https://cmsoms.cern.ch/agg/api\", api_version=\"v1\", verbose=True, cert_verify=True, retry_on_err_sec=0, proxies={}) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"omsapi/omsapi/#query","text":"full signature: def query(self, resource, query_validation=True) comments: (no valid documentation found)","title":"&#10551; query"},{"location":"omsapi/omsapi/#auth95oidc_1","text":"full signature: def auth_oidc(self, client_id, client_secret, audience=\"cmsoms-prod\", proxies={}) comments: (no valid documentation found)","title":"&#10551; auth_oidc"},{"location":"omsapi/omsapi/#auth95krb","text":"full signature: def auth_krb(self, cookie_path=\"ssocookies.txt\") comments: (no valid documentation found)","title":"&#10551; auth_krb"},{"location":"omsapi/omsapi/#rm95file","text":"full signature: def rm_file(filename) comments: (no valid documentation found)","title":"rm_file"},{"location":"omsapi/urls/","text":"urls","title":"urls"},{"location":"omsapi/urls/#urls","text":"","title":"urls"},{"location":"omsinterface/","text":"Tools for obtaining OMS information in json format !WARNING: superseded by newer OMS API version, see omsapi folder (as opposed to omsinterface here)! The code in this folder still works (on May 21 2021 at least) but it is nowhere used in the other notebooks in this project and will not be maintained. It can however be used as an alternative / backup way of accessing OMS that does not require to register your own app (see omsapi for details), a CERN username and password suffice. References: The code is largely based on / copied from the wbmcrawlr tool ( https://github.com/CMSTrackerDPG/wbmcrawlr ) and the cernrequests package ( https://github.com/CMSTrackerDPG/cernrequests ) by the Tracker DPG. All credits to the Tracker DPG group, all mistakes in copying or modifying are of course my own. How to use: Open example.ipynb The configuration should be quite self-explanatory: choose the mode ('run' for run information, 'lumsisections' for per-lumisection information, other modes also available), enter the run number for which to retrieve the information, choose the mode for authentication (via CERN username and password or via CERN grid certificate). In case you choose to use a certificate, first edit the file 'cert.py' to set the correct paths to where you stored your certificate and key. Else you will be prompted to enter your username and password. Run the cells below, the requested information should now be stored in the specified output json file. Instead, you could also directly use the resulting object in your script without writing it and loading it to a json file. Notes: Preliminary implementation, will be extended to e.g. filter on specific data fields only (for example only keep pileup or luminosity per lumisection), etc. Update: no extensions are planned, as this method of accessing OMS is superseded by a new API version, see above. The authentication with a certificate still has an issue. For now, you need both a certificate and a username/password to make the data retrieval work. The method using username and password seems to work without additional certificate. For more information on how to obtain a certificate, follow this link: https://github.com/CMSTrackerDPG/cernrequests#prerequisites One could also install the wbmcrawlr tool (from https://github.com/CMSTrackerDPG/wbmcrawlr ) and use it directly. Both methods are equivalent up to now, except these notebooks don't require additional installation of the wbmcrawler tool and cernrequests module.","title":"README"},{"location":"omsinterface/cert/","text":"cert","title":"cert"},{"location":"omsinterface/cert/#cert","text":"","title":"cert"},{"location":"omsinterface/connectiontools/","text":"connectiontools Tools for checking connectivity to specific URLs and obtaining cookies The functions in this script are not my own, but largely based on the wbmcrawler and cernrequests packages. See the readme file in this directory for more information. For normal users these functions should not be called directly, everything is handled by a single call to get_oms_data.py / get_oms_data. See get_oms_data.py in this directory for more information. check_connectivity full signature: def check_connectivity(url) comments: (no valid documentation found) get_cookies full signature: def get_cookies(url, authmode, **kwargs) comments: (no valid documentation found) get_cookies_from_certificate full signature: def get_cookies_from_certificate(url, certificate, **kwargs) comments: (no valid documentation found) get_cookies_from_login full signature: def get_cookies_from_login(url, login, **kwargs) comments: (no valid documentation found) _construct_certificate_authentication_url full signature: def _construct_certificate_authentication_url(login_redirect_url) comments: (no valid documentation found) _extract_login_form full signature: def _extract_login_form( xml_response_content ) comments: (no valid documentation found) _modify_xml_content full signature: def _modify_xml_content( xml_response_content ) comments: (no valid documentation found)","title":"connectiontools"},{"location":"omsinterface/connectiontools/#connectiontools","text":"Tools for checking connectivity to specific URLs and obtaining cookies The functions in this script are not my own, but largely based on the wbmcrawler and cernrequests packages. See the readme file in this directory for more information. For normal users these functions should not be called directly, everything is handled by a single call to get_oms_data.py / get_oms_data. See get_oms_data.py in this directory for more information.","title":"connectiontools"},{"location":"omsinterface/connectiontools/#check95connectivity","text":"full signature: def check_connectivity(url) comments: (no valid documentation found)","title":"check_connectivity"},{"location":"omsinterface/connectiontools/#get95cookies","text":"full signature: def get_cookies(url, authmode, **kwargs) comments: (no valid documentation found)","title":"get_cookies"},{"location":"omsinterface/connectiontools/#get95cookies95from95certificate","text":"full signature: def get_cookies_from_certificate(url, certificate, **kwargs) comments: (no valid documentation found)","title":"get_cookies_from_certificate"},{"location":"omsinterface/connectiontools/#get95cookies95from95login","text":"full signature: def get_cookies_from_login(url, login, **kwargs) comments: (no valid documentation found)","title":"get_cookies_from_login"},{"location":"omsinterface/connectiontools/#95construct95certificate95authentication95url","text":"full signature: def _construct_certificate_authentication_url(login_redirect_url) comments: (no valid documentation found)","title":"_construct_certificate_authentication_url"},{"location":"omsinterface/connectiontools/#95extract95login95form","text":"full signature: def _extract_login_form( xml_response_content ) comments: (no valid documentation found)","title":"_extract_login_form"},{"location":"omsinterface/connectiontools/#95modify95xml95content","text":"full signature: def _modify_xml_content( xml_response_content ) comments: (no valid documentation found)","title":"_modify_xml_content"},{"location":"omsinterface/get_oms_data/","text":"get oms data Main function in omsinterface to retrieve information from OMS How to use? See the readme file in this directory and the notebook example.ipynb! get_oms_data full signature: def get_oms_data( mode, run, hltpathname='', authmode='login' ) comments: main function for retrieving information from the OMS database input arguments: - mode: a string representing the type of information to retrieve. the following options are currently supported: 'run' -> retrieve information per run 'lumisections' -> retrieve information per lumisection 'hltpathinfos' -> get information on the available HLT paths for a given run, in particular their names, 'hltrate' -> get the trigger rate of a specified HLT path 'hltrates' -> get the trigger rate for all available HLT paths - run: a single run number (integer format) note: in case mode is 'run', the run argument can also be a tuple representing a range of runs. - hltpathname: the name of a HLT path for which to retrieve the trigger rate. ignored if mode is not 'hltrate' - authmode: string representing mode of authentication. choose from 'login' (you will be prompted for your cern username and password) or 'certificate' (requires you to have set up the path to a valid certificate) returns: - a list or dict (depending on the specifications) containing all information. simply print it to see how to access the exact values you need.","title":"get_oms_data"},{"location":"omsinterface/get_oms_data/#get-oms-data","text":"Main function in omsinterface to retrieve information from OMS How to use? See the readme file in this directory and the notebook example.ipynb!","title":"get oms data"},{"location":"omsinterface/get_oms_data/#get95oms95data","text":"full signature: def get_oms_data( mode, run, hltpathname='', authmode='login' ) comments: main function for retrieving information from the OMS database input arguments: - mode: a string representing the type of information to retrieve. the following options are currently supported: 'run' -> retrieve information per run 'lumisections' -> retrieve information per lumisection 'hltpathinfos' -> get information on the available HLT paths for a given run, in particular their names, 'hltrate' -> get the trigger rate of a specified HLT path 'hltrates' -> get the trigger rate for all available HLT paths - run: a single run number (integer format) note: in case mode is 'run', the run argument can also be a tuple representing a range of runs. - hltpathname: the name of a HLT path for which to retrieve the trigger rate. ignored if mode is not 'hltrate' - authmode: string representing mode of authentication. choose from 'login' (you will be prompted for your cern username and password) or 'certificate' (requires you to have set up the path to a valid certificate) returns: - a list or dict (depending on the specifications) containing all information. simply print it to see how to access the exact values you need.","title":"get_oms_data"},{"location":"omsinterface/omstools/","text":"omstools Tools for accessing the OMS database The functions in this script are not my own, but largely based on the wbmcrawler and cernrequests packages. See the readme file in this directory for more information. For normal users these functions should not be called directly, everything is handled by a single call to get_oms_data.py / get_oms_data. See get_oms_data.py in this directory for more information. check_oms_connectivity full signature: def check_oms_connectivity() comments: (no valid documentation found) get_oms_cookies full signature: def get_oms_cookies( authmode, **kwargs ) comments: (no valid documentation found) _get_oms_resource_within_cern_gpn full signature: def _get_oms_resource_within_cern_gpn(relative_url) comments: (no valid documentation found) _get_oms_resource_authenticated full signature: def _get_oms_resource_authenticated(relative_url, cookies) comments: (no valid documentation found) get_oms_resource full signature: def get_oms_resource(table, parameters, **kwargs) comments: (no valid documentation found) _get_single_resource full signature: def _get_single_resource(table, parameters, **kwargs) comments: (no valid documentation found) get_run full signature: def get_run(run_number, **kwargs) comments: (no valid documentation found) get_fill full signature: def get_fill(fill_number, **kwargs) comments: (no valid documentation found) _get_resources_page full signature: def _get_resources_page(table, parameters, page, page_size, **kwargs) comments: (no valid documentation found) get_resources full signature: def get_resources(table, parameters, page_size=PAGE_SIZE, silent=False, **kwargs) comments: (no valid documentation found) get_runs full signature: def get_runs(begin, end, **kwargs) comments: (no valid documentation found) get_fills full signature: def get_fills(begin, end, **kwargs) comments: (no valid documentation found) get_lumisection_count full signature: def get_lumisection_count(run_number, **kwargs) comments: (no valid documentation found) get_lumisections full signature: def get_lumisections( run_number=None, fill_number=None, start_time=None, end_time=None, **kwargs) comments: (no valid documentation found) get_hltpathinfos full signature: def get_hltpathinfos(run_number, **kwargs) comments: (no valid documentation found) get_hltpathrates full signature: def get_hltpathrates(run_number, path_name, **kwargs) comments: (no valid documentation found) get_all_hltpathrates full signature: def get_all_hltpathrates(run_number, silent=False, **kwargs) comments: (no valid documentation found) calc_page_count full signature: def calc_page_count(resource_count, page_size) comments: (no valid documentation found) flatten_resource full signature: def flatten_resource(response) comments: (no valid documentation found) progress_bar full signature: def progress_bar(current, total, text=\"\", filler=\"#\") comments: (no valid documentation found) print_progress full signature: def print_progress(current, total, text=\"\", *args, **kwargs) comments: (no valid documentation found)","title":"omstools"},{"location":"omsinterface/omstools/#omstools","text":"Tools for accessing the OMS database The functions in this script are not my own, but largely based on the wbmcrawler and cernrequests packages. See the readme file in this directory for more information. For normal users these functions should not be called directly, everything is handled by a single call to get_oms_data.py / get_oms_data. See get_oms_data.py in this directory for more information.","title":"omstools"},{"location":"omsinterface/omstools/#check95oms95connectivity","text":"full signature: def check_oms_connectivity() comments: (no valid documentation found)","title":"check_oms_connectivity"},{"location":"omsinterface/omstools/#get95oms95cookies","text":"full signature: def get_oms_cookies( authmode, **kwargs ) comments: (no valid documentation found)","title":"get_oms_cookies"},{"location":"omsinterface/omstools/#95get95oms95resource95within95cern95gpn","text":"full signature: def _get_oms_resource_within_cern_gpn(relative_url) comments: (no valid documentation found)","title":"_get_oms_resource_within_cern_gpn"},{"location":"omsinterface/omstools/#95get95oms95resource95authenticated","text":"full signature: def _get_oms_resource_authenticated(relative_url, cookies) comments: (no valid documentation found)","title":"_get_oms_resource_authenticated"},{"location":"omsinterface/omstools/#get95oms95resource","text":"full signature: def get_oms_resource(table, parameters, **kwargs) comments: (no valid documentation found)","title":"get_oms_resource"},{"location":"omsinterface/omstools/#95get95single95resource","text":"full signature: def _get_single_resource(table, parameters, **kwargs) comments: (no valid documentation found)","title":"_get_single_resource"},{"location":"omsinterface/omstools/#get95run","text":"full signature: def get_run(run_number, **kwargs) comments: (no valid documentation found)","title":"get_run"},{"location":"omsinterface/omstools/#get95fill","text":"full signature: def get_fill(fill_number, **kwargs) comments: (no valid documentation found)","title":"get_fill"},{"location":"omsinterface/omstools/#95get95resources95page","text":"full signature: def _get_resources_page(table, parameters, page, page_size, **kwargs) comments: (no valid documentation found)","title":"_get_resources_page"},{"location":"omsinterface/omstools/#get95resources","text":"full signature: def get_resources(table, parameters, page_size=PAGE_SIZE, silent=False, **kwargs) comments: (no valid documentation found)","title":"get_resources"},{"location":"omsinterface/omstools/#get95runs","text":"full signature: def get_runs(begin, end, **kwargs) comments: (no valid documentation found)","title":"get_runs"},{"location":"omsinterface/omstools/#get95fills","text":"full signature: def get_fills(begin, end, **kwargs) comments: (no valid documentation found)","title":"get_fills"},{"location":"omsinterface/omstools/#get95lumisection95count","text":"full signature: def get_lumisection_count(run_number, **kwargs) comments: (no valid documentation found)","title":"get_lumisection_count"},{"location":"omsinterface/omstools/#get95lumisections","text":"full signature: def get_lumisections( run_number=None, fill_number=None, start_time=None, end_time=None, **kwargs) comments: (no valid documentation found)","title":"get_lumisections"},{"location":"omsinterface/omstools/#get95hltpathinfos","text":"full signature: def get_hltpathinfos(run_number, **kwargs) comments: (no valid documentation found)","title":"get_hltpathinfos"},{"location":"omsinterface/omstools/#get95hltpathrates","text":"full signature: def get_hltpathrates(run_number, path_name, **kwargs) comments: (no valid documentation found)","title":"get_hltpathrates"},{"location":"omsinterface/omstools/#get95all95hltpathrates","text":"full signature: def get_all_hltpathrates(run_number, silent=False, **kwargs) comments: (no valid documentation found)","title":"get_all_hltpathrates"},{"location":"omsinterface/omstools/#calc95page95count","text":"full signature: def calc_page_count(resource_count, page_size) comments: (no valid documentation found)","title":"calc_page_count"},{"location":"omsinterface/omstools/#flatten95resource","text":"full signature: def flatten_resource(response) comments: (no valid documentation found)","title":"flatten_resource"},{"location":"omsinterface/omstools/#progress95bar","text":"full signature: def progress_bar(current, total, text=\"\", filler=\"#\") comments: (no valid documentation found)","title":"progress_bar"},{"location":"omsinterface/omstools/#print95progress","text":"full signature: def print_progress(current, total, text=\"\", *args, **kwargs) comments: (no valid documentation found)","title":"print_progress"},{"location":"omsinterface/urls/","text":"urls","title":"urls"},{"location":"omsinterface/urls/#urls","text":"","title":"urls"},{"location":"src/DataLoader/","text":"DataLoader [class] DataLoader comments: class for loading histograms from disk the input usually consists of: - a csv file or a folder containing csv files in the correct format - a set of histogram names to load - a specification in terms of eras or years the output typically consists of pandas dataframes containing the requested histograms. \u2937 __init__ full signature: def __init__( self ) comments: initializer \u2937 check_year full signature: def check_year( self, year ) comments: (no valid documentation found) \u2937 check_eras full signature: def check_eras( self, eras, year ) comments: (no valid documentation found) \u2937 check_dim full signature: def check_dim( self, dim ) comments: (no valid documentation found) \u2937 check_eos full signature: def check_eos( self ) comments: (no valid documentation found) \u2937 get_default_data_dirs full signature: def get_default_data_dirs( self, year='2017', eras=[], dim=1 ) comments: get the default data directories for the data for this project note: this returns the directories where the data is currently stored; might change in future reprocessings of the data, and should be extended for upcoming Run-III data. note: default directories are on the /eos file system. this function will throw an exception if it has not access to /eos. input arguments: - year: data-taking year, should be '2017' or '2018' so far (default: 2017) - eras: list of valid eras for the given data-taking year (default: all eras) - dim: dimension of requested histograms (1 or 2) \u2937 get_csv_files_in_dir full signature: def get_csv_files_in_dir( self, inputdir, sort=True ) comments: get a (sorted) list of csv files in a given input directory input arguments: - inputdir: directory to scan for csv files - sort: boolean whether to sort the files \u2937 get_csv_files_in_dirs full signature: def get_csv_files_in_dirs( self, inputdirs, sort=True ) comments: find the csv files in a set of input directories and return them in one list input arguments: - list of input directories where to look for csv files - sort: see get_csv_files_in_dir \u2937 get_default_csv_files full signature: def get_default_csv_files( self, year='2017', eras=[], dim=1, sort=True ) comments: read the csv files from the default directories with input data for this project note: default directories are on the /eos file system. this function will throw an exception if it has not access to /eos. input arguments: - year, eras, dim: see get_default_data_dirs! - sort: see get_csv_files_in_dir! \u2937 get_dataframe_from_file full signature: def get_dataframe_from_file( self, csvfile, histnames=[] ) comments: load histograms from a given file \u2937 get_dataframe_from_files full signature: def get_dataframe_from_files( self, csvfiles, histnames=[] ) comments: load histograms from a given set of files \u2937 write_dataframe_to_file full signature: def write_dataframe_to_file( self, df, csvfile ) comments: write a dataframe to a csv file","title":"DataLoader"},{"location":"src/DataLoader/#dataloader","text":"","title":"DataLoader"},{"location":"src/DataLoader/#class-dataloader","text":"comments: class for loading histograms from disk the input usually consists of: - a csv file or a folder containing csv files in the correct format - a set of histogram names to load - a specification in terms of eras or years the output typically consists of pandas dataframes containing the requested histograms.","title":"[class] DataLoader"},{"location":"src/DataLoader/#9595init9595","text":"full signature: def __init__( self ) comments: initializer","title":"&#10551; __init__"},{"location":"src/DataLoader/#check95year","text":"full signature: def check_year( self, year ) comments: (no valid documentation found)","title":"&#10551; check_year"},{"location":"src/DataLoader/#check95eras","text":"full signature: def check_eras( self, eras, year ) comments: (no valid documentation found)","title":"&#10551; check_eras"},{"location":"src/DataLoader/#check95dim","text":"full signature: def check_dim( self, dim ) comments: (no valid documentation found)","title":"&#10551; check_dim"},{"location":"src/DataLoader/#check95eos","text":"full signature: def check_eos( self ) comments: (no valid documentation found)","title":"&#10551; check_eos"},{"location":"src/DataLoader/#get95default95data95dirs","text":"full signature: def get_default_data_dirs( self, year='2017', eras=[], dim=1 ) comments: get the default data directories for the data for this project note: this returns the directories where the data is currently stored; might change in future reprocessings of the data, and should be extended for upcoming Run-III data. note: default directories are on the /eos file system. this function will throw an exception if it has not access to /eos. input arguments: - year: data-taking year, should be '2017' or '2018' so far (default: 2017) - eras: list of valid eras for the given data-taking year (default: all eras) - dim: dimension of requested histograms (1 or 2)","title":"&#10551; get_default_data_dirs"},{"location":"src/DataLoader/#get95csv95files95in95dir","text":"full signature: def get_csv_files_in_dir( self, inputdir, sort=True ) comments: get a (sorted) list of csv files in a given input directory input arguments: - inputdir: directory to scan for csv files - sort: boolean whether to sort the files","title":"&#10551; get_csv_files_in_dir"},{"location":"src/DataLoader/#get95csv95files95in95dirs","text":"full signature: def get_csv_files_in_dirs( self, inputdirs, sort=True ) comments: find the csv files in a set of input directories and return them in one list input arguments: - list of input directories where to look for csv files - sort: see get_csv_files_in_dir","title":"&#10551; get_csv_files_in_dirs"},{"location":"src/DataLoader/#get95default95csv95files","text":"full signature: def get_default_csv_files( self, year='2017', eras=[], dim=1, sort=True ) comments: read the csv files from the default directories with input data for this project note: default directories are on the /eos file system. this function will throw an exception if it has not access to /eos. input arguments: - year, eras, dim: see get_default_data_dirs! - sort: see get_csv_files_in_dir!","title":"&#10551; get_default_csv_files"},{"location":"src/DataLoader/#get95dataframe95from95file","text":"full signature: def get_dataframe_from_file( self, csvfile, histnames=[] ) comments: load histograms from a given file","title":"&#10551; get_dataframe_from_file"},{"location":"src/DataLoader/#get95dataframe95from95files","text":"full signature: def get_dataframe_from_files( self, csvfiles, histnames=[] ) comments: load histograms from a given set of files","title":"&#10551; get_dataframe_from_files"},{"location":"src/DataLoader/#write95dataframe95to95file","text":"full signature: def write_dataframe_to_file( self, df, csvfile ) comments: write a dataframe to a csv file","title":"&#10551; write_dataframe_to_file"},{"location":"src/HistStruct/","text":"HistStruct HistStruct: consistent treatment of multiple histogram types The HistStruct class is intended to be the main data structure used within this framework. A HistStruct object basically consists of a mutually consistent collection of numpy arrays, where each numpy array corresponds to one histogram type, with dimensions (number of histograms, number of bins). The HistStruct has functions to easily perform the following common tasks (among others): - select a subset of runs and/or lumisections (e.g. using a custom or predefined json file formatted selector), - prepare the data for machine learning training, with all kinds of preprocessing, - evaluate classifiers (machine learning types or other). Up to now the HistStruct is not used in many places, the main reason being that most of the tutorials for example were written (or at leasted started) before this class. When only processing a single histogram type, the HistStruct might be a bit of an overkill and one could choose to operate on the dataframe directly. However, especially when using multiple histogram types, the HistStruct is very handy to keep everything consistent. See the tutorial autoencoder_combine.ipynb for an important example! [class] HistStruct comments: main data structure used within this framework a HistStruct object basically consists of a mutually consistent collection of numpy arrays, where each numpy array corresponds to one histogram type, with dimensions (number of histograms, number of bins). the HistStruct has functions to easily perform the following common tasks (among others): - select a subset of runs and/or lumisections (e.g. using a json file formatted selector), - prepare the data for machine learning training - evaluate classifiers (machine learning types or other) \u2937 __init__ full signature: def __init__( self ) comments: empty initializer, setting all containers to empty defaults a HistStruct object has the following properties: histnames: list of histogram names histograms: dict mapping histogram name to 2D numpy array of histograms (shape (nhists,nbins)) nentries: dict mapping histogram name to 1D numpy array of number of entries per histogram (same length as histograms) histranges: dict mapping histogram name to tuple with (xmin, xmax) runnbs: 1D numpy array of run numbers (same length as histograms) lsnbs: 1D numpy array of lumisection numbers (same length as histograms) globalscores: 1D numpy array of global score per lumisection (same length as histograms) classifiers: dict mapping histogram name to object of type HistogramClassifier scores: dict mapping histogram name to 1D numpy array of values associated to the histograms (same length as histograms) masks: dict mapping name to 1D numpy array of booleans (same length as histograms) that can be used for masking exthistograms: dict of dicts similar to histograms for additional (e.g. artificially generated) histograms extscores: dict of dicts similar to scores for additional (e.g. artificially generated) histograms extglobalscores: dict of lists similar to scores for additional (e.g. artificially generated) histograms \u2937 __str__ full signature: def __str__( self ) comments: get a printable representation of a HistStruct \u2937 save full signature: def save( self, path, save_classifiers=True ) comments: save a HistStruct object to a pkl file input arguments: - path where to store the file (appendix .zip is automatically appended) - save_classifiers: a boolean whether to include the classifiers if present in the HistStruct [class] classifiers = dict comments: (no valid documentation found) [class] classifier.save comments: (no valid documentation found) \u2937 load full signature: def load( self, path, load_classifiers=True, verbose=False ) comments: load a HistStruct object from a pkl file input arguments: - path to a zip file containing a HistStruct object - load_classifiers: a boolean whether to load the classifiers if present - verbose: boolean whether to print some information \u2937 add_dataframe full signature: def add_dataframe( self, df, cropslices=None, donormalize=True, rebinningfactor=None ) comments: add a dataframe to a HistStruct input arguments: - df: a pandas dataframe as read from the input csv files - cropslices: list of slices (one per dimension) by which to crop the histograms - donormalize: boolean whether to normalize the histograms - rebinningfactor: factor by which to group bins together for more details on cropslices, donormalize and rebinningfactor, see hist_utils.py / preparedatafromdf! notes: - the new dataframe can contain one or multiple histogram types - the new dataframe must contain the same run and lumisection numbers (for each histogram type in it) as already present in the HistStruct, except if it is the first one to be added - alternative to adding the dataframe with the options cropslices, donormalize and rebinningfactor (that will be passed down to preparedatafromdf), one can also call preparedatafromdf manually and add it with add_histograms, allowing for more control over complicated preprocessing. \u2937 add_histograms full signature: def add_histograms( self, histname, histograms, runnbs, lsnbs, nentries=None ) comments: add a set of histograms to a HistStruct input arguments: - histname: name of the histogram type to be added - histograms: a numpy array of shape (nhistograms,nbins), assumed to be of a single type - runnbs: a 1D list or array of length nhistograms containing the run number per histogram - lsnbs: a 1D list or array of length nhistograms containing the lumisection number per histogram - nentries: a 1D list or array of length nhistograms containing the number of entries per histogram notes: - must be provided explicitly since histograms might be normalized, in which case the number of entries cannot be determined from the sum of bin contents. - used for (de-)selecting histograms with sufficient statistics; if you don't need that type of selection, nentries can be left at default. - default is None, meaning all entries will be set to zero. notes: - no preprocessing is performed, this is assumed to have been done manually (if needed) before adding the histograms - runnbs and lsnbs must correspond to what is already in the current HistStruct, except if this is the first set of histogram to be added - see also add_dataframe for an alternative way of adding histograms \u2937 add_globalscores full signature: def add_globalscores( self, globalscores ) comments: add an array of global scores (one per lumisection) input arguments: - globalscores: 1D numpy array of scores (must have same length as lumisection and run numbers) \u2937 add_extglobalscores full signature: def add_extglobalscores( self, extname, globalscores ) comments: add an array of global scores (one per lumisection) for a specified extra set of histograms in the HistStruct input arguments: - extname: name of extra histogram set - globalscores: 1D numpy array of scores note: this function checks if all histogram types in this set contain the same number of histograms, (and that this number corresponds to the length of globalscores) else adding globalscores is meaningless \u2937 get_globalscores_jsonformat full signature: def get_globalscores_jsonformat( self, working_point=None ) comments: make a json format listing all lumisections in this histstruct the output list has entries for global score, pass/fail given working point, and masks input arguments: - working_point: if present, an entry will be made for each lumisection whether it passes this working point \u2937 add_exthistograms full signature: def add_exthistograms( self, extname, histname, histograms, overwrite=False ) comments: add a set of extra histograms to a HistStruct these histograms are not assumed to correspond to physical run/lumisections numbers (e.g. resampled ones), and no consistency checks are done input arguments: - extname: name of the extra histogram set (you can add multiple, e.g. resampled_good, resampled_bad and/or resampled_training) - histname: name of the histogram type - histograms: a numpy array of shape (nhistograms,nbins) - overwrite: boolean whether to overwrite a set of histograms of the same name if present (default: raise exception) \u2937 add_mask full signature: def add_mask( self, name, mask ) comments: add a mask to a HistStruct input arguments: - name: a name for the mask - mask: a 1D np array of booleans with same length as number of lumisections in HistStruct \u2937 remove_mask full signature: def remove_mask( self, name ) comments: inverse operation of add_mask \u2937 add_json_mask full signature: def add_json_mask( self, name, jsondict ) comments: add a mask corresponding to a json dict input arguments: - name: a name for the mask - jsondict: a dictionary in typical json format (see the golden json file for inspiration) all lumisections present in the jsondict will be masked True, the others False. \u2937 add_goldenjson_mask full signature: def add_goldenjson_mask( self, name ) comments: add a mask corresponding to the golden json file input arguments: - name: a name for the mask \u2937 add_dcsonjson_mask full signature: def add_dcsonjson_mask( self, name ) comments: add a mask corresponding to the DCS-bit on json file input arguments: - name: a name for the mask \u2937 add_stat_mask full signature: def add_stat_mask( self, name, histnames=None, min_entries_to_bins_ratio=-1, max_entries_to_bins_ratio=-1 ) comments: add a mask corresponding to lumisections where all histograms have statistics within given bounds input arguments: - histnames: list of histogram names to take into account for making the mask (default: all in the HistStruct) - min_entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics (default: no lower boundary) - max_entries_to_bins_ratio: same but upper boundary instead of lower boundary (default: no upper boundary) \u2937 add_highstat_mask full signature: def add_highstat_mask( self, name, histnames=None, entries_to_bins_ratio=100 ) comments: shorthand call to add_stat_mask with only lower boundary and no upper boundary for statistics input arguments: - entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics others: see add_stat_mask \u2937 get_combined_mask full signature: def get_combined_mask( self, names ) comments: get a combined mask given multiple mask names mostly for internal use; externally you can use get_histograms( histname, <list of mask names>) directly \u2937 get_masknames full signature: def get_masknames( self ) comments: return a simple list of all mask names in the current HistStruct \u2937 get_runnbs full signature: def get_runnbs( self, masknames=None ) comments: get the array of run numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array) \u2937 get_lsnbs full signature: def get_lsnbs( self, masknames=None ) comments: get the array of lumisection numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array) \u2937 get_index full signature: def get_index( self, runnb, lsnb ) comments: get the index in the current HistStruct of a given run and lumisection number input arguments: - runnb and lsnb: run and lumisection number respectively \u2937 get_scores full signature: def get_scores( self, histname=None, masknames=None ) comments: get the array of scores for a given histogram type, optionally after masking input arguments: - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores - masknames: list of names of masks (default: no masking, return full array) notes: - this method takes the scores from the HistStruct.scores attribute; make sure to have evaluated the classifiers before calling this method, else an exception will be thrown. \u2937 get_scores_array full signature: def get_scores_array( self, masknames=None ) comments: similar to get_scores, but with different return type: np array of shape (nhistograms, nhistogramtypes) \u2937 get_extscores full signature: def get_extscores( self, extname, histname=None ) comments: get the array of scores for a given histogram type in a given extra set. input arguments: - extname: name of the extra set (see also add_exthistograms) - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores notes: - this method takes the scores from the HistStruct.extscores attribute; make sure to have evaluated the classifiers before calling this method, else an exception will be thrown. \u2937 get_extscores_array full signature: def get_extscores_array( self, extname ) comments: similar to get_extscores, but with different return type: np array of shape (nhistograms, nhistogramtypes) \u2937 get_scores_ls full signature: def get_scores_ls( self, runnb, lsnb, histnames=None, suppresswarnings=False ) comments: get the scores for a given run/lumisection number and for given histogram names input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score) notes: - this method takes the scores from the HistStruct.scores attribute; make sure to have evaluated the classifiers before calling this method, else the returned scores will be None. \u2937 get_globalscores full signature: def get_globalscores( self, masknames=None ) comments: get the array of global scores, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array) notes: - this method takes the scores from the HistStruct.globalscores attribute; make sure to have set this attribute with add_globalscores, else an exception will be thrown. \u2937 get_globalscore_ls full signature: def get_globalscore_ls( self, runnb, lsnb ) comments: get the global score for a given run/lumisection number input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score) notes: - this method takes the scores from the HistStruct.scores attribute; make sure to have evaluated the classifiers before calling this method, else the returned scores will be None. \u2937 get_extglobalscores full signature: def get_extglobalscores( self, extname ) comments: get the array of global scores for one of the extra histogram sets input arguments: - extname: name of the extra histogram set notes: - this method takes the scores from the HistStruct.extglobalscores attribute; make sure to have set this attribute with add_extglobalscores, else an exception will be thrown. \u2937 get_histograms full signature: def get_histograms( self, histname=None, masknames=None ) comments: get the array of histograms for a given type, optionally after masking input arguments: - histname: name of the histogram type to retrieve if None, return a dict matching histnames to arrays of histograms - masknames: list of names of masks (default: no masking, return full array) \u2937 get_exthistograms full signature: def get_exthistograms( self, extname, histname=None ) comments: get the array of extra histograms for a given set name and type name input arguments: - extname: name of the set of extra histograms (see also add_exthistograms) - histname: name of the histogram type to retrieve if None, return a dict matching histnames to arrays of histograms \u2937 add_classifier full signature: def add_classifier( self, histname, classifier, evaluate=False ) comments: add a histogram classifier for a given histogram name to the HistStruct input arguments: - histname: a valid histogram name present in the HistStruct to which this classifier applies - classifier: an object of type HistogramClassifier (i.e. of any class that derives from it) - evaluate: a bool whether to evaluate the classifier (and store the result in the 'scores' attribute) if set to True, the result is both returned and stored in the 'scores' attribute. \u2937 evaluate_classifier full signature: def evaluate_classifier( self, histname, extname=None ) comments: evaluate a histogram classifier for a given histogram name in the HistStruct input arguments: - histname: a valid histogram name present in the HistStruct for which to evaluate the classifier - extname: name of a set of extra histograms (see add_exthistograms) if None, will evaluate the classifer for the main set of histograms notes: - the result is both returned and stored in the 'scores' attribute \u2937 plot_histograms full signature: def plot_histograms( self, histnames=None, masknames=None, colorlist=[], labellist=[], transparencylist=[], titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a HistStruct, optionally after msking note: so far only for 1D hsitograms. case of 2D histograms requires different plotting method since they cannot be clearly overlaid. if a HistStruct contains both 1D and 2D histograms, the 1D histograms must be selected with the histnames argument. input arguments: - histnames: list of names of the histogram types to plot (default: all) - masknames: list of list of mask names note: each element in masknames represents a set of masks to apply; the histograms passing different sets of masks are plotted in different colors - colorlist: list of matplotlib colors, must have same length as masknames - labellist: list of labels for the legend, must have same legnth as masknames - transparencylist: list of transparency values, must have same length as masknames - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets \u2937 plot_ls full signature: def plot_ls( self, runnb, lsnb, histnames=None, histlabel=None, recohist=None, recohistlabel='Reconstruction', refhists=None, refhistslabel='Reference histograms', refhiststransparency=None, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their references and/or their reconstruction note: so far only for 1D histograms. case of 2D histograms requires different plotting method since they cannot be clearly overlaid. if a HistStruct contains both 1D and 2D histograms, the 1D histograms must be selected with the histnames argument. input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of histogram types to plot (default: all) - histlabel: legend entry for the histogram (default: run and lumisection number) - recohist: dict matching histogram names to reconstructed histograms notes: - 'reconstructed histograms' refers to e.g. autoencoder or NMF reconstructions; some models (e.g. simply looking at histogram moments) might not have this kind of reconstruction - in principle one histogram per key is expected, but still the the shape must be 2D (i.e. (1,nbins)) - in case recohist is set to 'auto', the reconstruction is calculated on the fly for the input histograms - recohistlabel: legend entry for the reco histograms - refhists: dict matching histogram names to reference histograms notes: - multiple histograms (i.e. a 2D array) per key are expected; in case there is only one reference histogram, it must be reshaped into (1,nbins) - refhistslabel: legend entry for the reference histograms - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets \u2937 plot_run full signature: def plot_run( self, runnb, masknames=None, recohist=None, recohistlabel='reco', refhists=None, refhistslabel='reference', doprint=False) comments: call plot_ls for all lumisections in a given run","title":"HistStruct"},{"location":"src/HistStruct/#histstruct","text":"HistStruct: consistent treatment of multiple histogram types The HistStruct class is intended to be the main data structure used within this framework. A HistStruct object basically consists of a mutually consistent collection of numpy arrays, where each numpy array corresponds to one histogram type, with dimensions (number of histograms, number of bins). The HistStruct has functions to easily perform the following common tasks (among others): - select a subset of runs and/or lumisections (e.g. using a custom or predefined json file formatted selector), - prepare the data for machine learning training, with all kinds of preprocessing, - evaluate classifiers (machine learning types or other). Up to now the HistStruct is not used in many places, the main reason being that most of the tutorials for example were written (or at leasted started) before this class. When only processing a single histogram type, the HistStruct might be a bit of an overkill and one could choose to operate on the dataframe directly. However, especially when using multiple histogram types, the HistStruct is very handy to keep everything consistent. See the tutorial autoencoder_combine.ipynb for an important example!","title":"HistStruct"},{"location":"src/HistStruct/#class-histstruct","text":"comments: main data structure used within this framework a HistStruct object basically consists of a mutually consistent collection of numpy arrays, where each numpy array corresponds to one histogram type, with dimensions (number of histograms, number of bins). the HistStruct has functions to easily perform the following common tasks (among others): - select a subset of runs and/or lumisections (e.g. using a json file formatted selector), - prepare the data for machine learning training - evaluate classifiers (machine learning types or other)","title":"[class] HistStruct"},{"location":"src/HistStruct/#9595init9595","text":"full signature: def __init__( self ) comments: empty initializer, setting all containers to empty defaults a HistStruct object has the following properties: histnames: list of histogram names histograms: dict mapping histogram name to 2D numpy array of histograms (shape (nhists,nbins)) nentries: dict mapping histogram name to 1D numpy array of number of entries per histogram (same length as histograms) histranges: dict mapping histogram name to tuple with (xmin, xmax) runnbs: 1D numpy array of run numbers (same length as histograms) lsnbs: 1D numpy array of lumisection numbers (same length as histograms) globalscores: 1D numpy array of global score per lumisection (same length as histograms) classifiers: dict mapping histogram name to object of type HistogramClassifier scores: dict mapping histogram name to 1D numpy array of values associated to the histograms (same length as histograms) masks: dict mapping name to 1D numpy array of booleans (same length as histograms) that can be used for masking exthistograms: dict of dicts similar to histograms for additional (e.g. artificially generated) histograms extscores: dict of dicts similar to scores for additional (e.g. artificially generated) histograms extglobalscores: dict of lists similar to scores for additional (e.g. artificially generated) histograms","title":"&#10551; __init__"},{"location":"src/HistStruct/#9595str9595","text":"full signature: def __str__( self ) comments: get a printable representation of a HistStruct","title":"&#10551; __str__"},{"location":"src/HistStruct/#save","text":"full signature: def save( self, path, save_classifiers=True ) comments: save a HistStruct object to a pkl file input arguments: - path where to store the file (appendix .zip is automatically appended) - save_classifiers: a boolean whether to include the classifiers if present in the HistStruct","title":"&#10551; save"},{"location":"src/HistStruct/#class-classifiers-dict","text":"comments: (no valid documentation found)","title":"[class] classifiers = dict"},{"location":"src/HistStruct/#class-classifiersave","text":"comments: (no valid documentation found)","title":"[class] classifier.save"},{"location":"src/HistStruct/#load","text":"full signature: def load( self, path, load_classifiers=True, verbose=False ) comments: load a HistStruct object from a pkl file input arguments: - path to a zip file containing a HistStruct object - load_classifiers: a boolean whether to load the classifiers if present - verbose: boolean whether to print some information","title":"&#10551; load"},{"location":"src/HistStruct/#add95dataframe","text":"full signature: def add_dataframe( self, df, cropslices=None, donormalize=True, rebinningfactor=None ) comments: add a dataframe to a HistStruct input arguments: - df: a pandas dataframe as read from the input csv files - cropslices: list of slices (one per dimension) by which to crop the histograms - donormalize: boolean whether to normalize the histograms - rebinningfactor: factor by which to group bins together for more details on cropslices, donormalize and rebinningfactor, see hist_utils.py / preparedatafromdf! notes: - the new dataframe can contain one or multiple histogram types - the new dataframe must contain the same run and lumisection numbers (for each histogram type in it) as already present in the HistStruct, except if it is the first one to be added - alternative to adding the dataframe with the options cropslices, donormalize and rebinningfactor (that will be passed down to preparedatafromdf), one can also call preparedatafromdf manually and add it with add_histograms, allowing for more control over complicated preprocessing.","title":"&#10551; add_dataframe"},{"location":"src/HistStruct/#add95histograms","text":"full signature: def add_histograms( self, histname, histograms, runnbs, lsnbs, nentries=None ) comments: add a set of histograms to a HistStruct input arguments: - histname: name of the histogram type to be added - histograms: a numpy array of shape (nhistograms,nbins), assumed to be of a single type - runnbs: a 1D list or array of length nhistograms containing the run number per histogram - lsnbs: a 1D list or array of length nhistograms containing the lumisection number per histogram - nentries: a 1D list or array of length nhistograms containing the number of entries per histogram notes: - must be provided explicitly since histograms might be normalized, in which case the number of entries cannot be determined from the sum of bin contents. - used for (de-)selecting histograms with sufficient statistics; if you don't need that type of selection, nentries can be left at default. - default is None, meaning all entries will be set to zero. notes: - no preprocessing is performed, this is assumed to have been done manually (if needed) before adding the histograms - runnbs and lsnbs must correspond to what is already in the current HistStruct, except if this is the first set of histogram to be added - see also add_dataframe for an alternative way of adding histograms","title":"&#10551; add_histograms"},{"location":"src/HistStruct/#add95globalscores","text":"full signature: def add_globalscores( self, globalscores ) comments: add an array of global scores (one per lumisection) input arguments: - globalscores: 1D numpy array of scores (must have same length as lumisection and run numbers)","title":"&#10551; add_globalscores"},{"location":"src/HistStruct/#add95extglobalscores","text":"full signature: def add_extglobalscores( self, extname, globalscores ) comments: add an array of global scores (one per lumisection) for a specified extra set of histograms in the HistStruct input arguments: - extname: name of extra histogram set - globalscores: 1D numpy array of scores note: this function checks if all histogram types in this set contain the same number of histograms, (and that this number corresponds to the length of globalscores) else adding globalscores is meaningless","title":"&#10551; add_extglobalscores"},{"location":"src/HistStruct/#get95globalscores95jsonformat","text":"full signature: def get_globalscores_jsonformat( self, working_point=None ) comments: make a json format listing all lumisections in this histstruct the output list has entries for global score, pass/fail given working point, and masks input arguments: - working_point: if present, an entry will be made for each lumisection whether it passes this working point","title":"&#10551; get_globalscores_jsonformat"},{"location":"src/HistStruct/#add95exthistograms","text":"full signature: def add_exthistograms( self, extname, histname, histograms, overwrite=False ) comments: add a set of extra histograms to a HistStruct these histograms are not assumed to correspond to physical run/lumisections numbers (e.g. resampled ones), and no consistency checks are done input arguments: - extname: name of the extra histogram set (you can add multiple, e.g. resampled_good, resampled_bad and/or resampled_training) - histname: name of the histogram type - histograms: a numpy array of shape (nhistograms,nbins) - overwrite: boolean whether to overwrite a set of histograms of the same name if present (default: raise exception)","title":"&#10551; add_exthistograms"},{"location":"src/HistStruct/#add95mask","text":"full signature: def add_mask( self, name, mask ) comments: add a mask to a HistStruct input arguments: - name: a name for the mask - mask: a 1D np array of booleans with same length as number of lumisections in HistStruct","title":"&#10551; add_mask"},{"location":"src/HistStruct/#remove95mask","text":"full signature: def remove_mask( self, name ) comments: inverse operation of add_mask","title":"&#10551; remove_mask"},{"location":"src/HistStruct/#add95json95mask","text":"full signature: def add_json_mask( self, name, jsondict ) comments: add a mask corresponding to a json dict input arguments: - name: a name for the mask - jsondict: a dictionary in typical json format (see the golden json file for inspiration) all lumisections present in the jsondict will be masked True, the others False.","title":"&#10551; add_json_mask"},{"location":"src/HistStruct/#add95goldenjson95mask","text":"full signature: def add_goldenjson_mask( self, name ) comments: add a mask corresponding to the golden json file input arguments: - name: a name for the mask","title":"&#10551; add_goldenjson_mask"},{"location":"src/HistStruct/#add95dcsonjson95mask","text":"full signature: def add_dcsonjson_mask( self, name ) comments: add a mask corresponding to the DCS-bit on json file input arguments: - name: a name for the mask","title":"&#10551; add_dcsonjson_mask"},{"location":"src/HistStruct/#add95stat95mask","text":"full signature: def add_stat_mask( self, name, histnames=None, min_entries_to_bins_ratio=-1, max_entries_to_bins_ratio=-1 ) comments: add a mask corresponding to lumisections where all histograms have statistics within given bounds input arguments: - histnames: list of histogram names to take into account for making the mask (default: all in the HistStruct) - min_entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics (default: no lower boundary) - max_entries_to_bins_ratio: same but upper boundary instead of lower boundary (default: no upper boundary)","title":"&#10551; add_stat_mask"},{"location":"src/HistStruct/#add95highstat95mask","text":"full signature: def add_highstat_mask( self, name, histnames=None, entries_to_bins_ratio=100 ) comments: shorthand call to add_stat_mask with only lower boundary and no upper boundary for statistics input arguments: - entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics others: see add_stat_mask","title":"&#10551; add_highstat_mask"},{"location":"src/HistStruct/#get95combined95mask","text":"full signature: def get_combined_mask( self, names ) comments: get a combined mask given multiple mask names mostly for internal use; externally you can use get_histograms( histname, <list of mask names>) directly","title":"&#10551; get_combined_mask"},{"location":"src/HistStruct/#get95masknames","text":"full signature: def get_masknames( self ) comments: return a simple list of all mask names in the current HistStruct","title":"&#10551; get_masknames"},{"location":"src/HistStruct/#get95runnbs","text":"full signature: def get_runnbs( self, masknames=None ) comments: get the array of run numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array)","title":"&#10551; get_runnbs"},{"location":"src/HistStruct/#get95lsnbs","text":"full signature: def get_lsnbs( self, masknames=None ) comments: get the array of lumisection numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array)","title":"&#10551; get_lsnbs"},{"location":"src/HistStruct/#get95index","text":"full signature: def get_index( self, runnb, lsnb ) comments: get the index in the current HistStruct of a given run and lumisection number input arguments: - runnb and lsnb: run and lumisection number respectively","title":"&#10551; get_index"},{"location":"src/HistStruct/#get95scores","text":"full signature: def get_scores( self, histname=None, masknames=None ) comments: get the array of scores for a given histogram type, optionally after masking input arguments: - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores - masknames: list of names of masks (default: no masking, return full array) notes: - this method takes the scores from the HistStruct.scores attribute; make sure to have evaluated the classifiers before calling this method, else an exception will be thrown.","title":"&#10551; get_scores"},{"location":"src/HistStruct/#get95scores95array","text":"full signature: def get_scores_array( self, masknames=None ) comments: similar to get_scores, but with different return type: np array of shape (nhistograms, nhistogramtypes)","title":"&#10551; get_scores_array"},{"location":"src/HistStruct/#get95extscores","text":"full signature: def get_extscores( self, extname, histname=None ) comments: get the array of scores for a given histogram type in a given extra set. input arguments: - extname: name of the extra set (see also add_exthistograms) - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores notes: - this method takes the scores from the HistStruct.extscores attribute; make sure to have evaluated the classifiers before calling this method, else an exception will be thrown.","title":"&#10551; get_extscores"},{"location":"src/HistStruct/#get95extscores95array","text":"full signature: def get_extscores_array( self, extname ) comments: similar to get_extscores, but with different return type: np array of shape (nhistograms, nhistogramtypes)","title":"&#10551; get_extscores_array"},{"location":"src/HistStruct/#get95scores95ls","text":"full signature: def get_scores_ls( self, runnb, lsnb, histnames=None, suppresswarnings=False ) comments: get the scores for a given run/lumisection number and for given histogram names input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score) notes: - this method takes the scores from the HistStruct.scores attribute; make sure to have evaluated the classifiers before calling this method, else the returned scores will be None.","title":"&#10551; get_scores_ls"},{"location":"src/HistStruct/#get95globalscores","text":"full signature: def get_globalscores( self, masknames=None ) comments: get the array of global scores, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array) notes: - this method takes the scores from the HistStruct.globalscores attribute; make sure to have set this attribute with add_globalscores, else an exception will be thrown.","title":"&#10551; get_globalscores"},{"location":"src/HistStruct/#get95globalscore95ls","text":"full signature: def get_globalscore_ls( self, runnb, lsnb ) comments: get the global score for a given run/lumisection number input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score) notes: - this method takes the scores from the HistStruct.scores attribute; make sure to have evaluated the classifiers before calling this method, else the returned scores will be None.","title":"&#10551; get_globalscore_ls"},{"location":"src/HistStruct/#get95extglobalscores","text":"full signature: def get_extglobalscores( self, extname ) comments: get the array of global scores for one of the extra histogram sets input arguments: - extname: name of the extra histogram set notes: - this method takes the scores from the HistStruct.extglobalscores attribute; make sure to have set this attribute with add_extglobalscores, else an exception will be thrown.","title":"&#10551; get_extglobalscores"},{"location":"src/HistStruct/#get95histograms","text":"full signature: def get_histograms( self, histname=None, masknames=None ) comments: get the array of histograms for a given type, optionally after masking input arguments: - histname: name of the histogram type to retrieve if None, return a dict matching histnames to arrays of histograms - masknames: list of names of masks (default: no masking, return full array)","title":"&#10551; get_histograms"},{"location":"src/HistStruct/#get95exthistograms","text":"full signature: def get_exthistograms( self, extname, histname=None ) comments: get the array of extra histograms for a given set name and type name input arguments: - extname: name of the set of extra histograms (see also add_exthistograms) - histname: name of the histogram type to retrieve if None, return a dict matching histnames to arrays of histograms","title":"&#10551; get_exthistograms"},{"location":"src/HistStruct/#add95classifier","text":"full signature: def add_classifier( self, histname, classifier, evaluate=False ) comments: add a histogram classifier for a given histogram name to the HistStruct input arguments: - histname: a valid histogram name present in the HistStruct to which this classifier applies - classifier: an object of type HistogramClassifier (i.e. of any class that derives from it) - evaluate: a bool whether to evaluate the classifier (and store the result in the 'scores' attribute) if set to True, the result is both returned and stored in the 'scores' attribute.","title":"&#10551; add_classifier"},{"location":"src/HistStruct/#evaluate95classifier","text":"full signature: def evaluate_classifier( self, histname, extname=None ) comments: evaluate a histogram classifier for a given histogram name in the HistStruct input arguments: - histname: a valid histogram name present in the HistStruct for which to evaluate the classifier - extname: name of a set of extra histograms (see add_exthistograms) if None, will evaluate the classifer for the main set of histograms notes: - the result is both returned and stored in the 'scores' attribute","title":"&#10551; evaluate_classifier"},{"location":"src/HistStruct/#plot95histograms","text":"full signature: def plot_histograms( self, histnames=None, masknames=None, colorlist=[], labellist=[], transparencylist=[], titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a HistStruct, optionally after msking note: so far only for 1D hsitograms. case of 2D histograms requires different plotting method since they cannot be clearly overlaid. if a HistStruct contains both 1D and 2D histograms, the 1D histograms must be selected with the histnames argument. input arguments: - histnames: list of names of the histogram types to plot (default: all) - masknames: list of list of mask names note: each element in masknames represents a set of masks to apply; the histograms passing different sets of masks are plotted in different colors - colorlist: list of matplotlib colors, must have same length as masknames - labellist: list of labels for the legend, must have same legnth as masknames - transparencylist: list of transparency values, must have same length as masknames - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets","title":"&#10551; plot_histograms"},{"location":"src/HistStruct/#plot95ls","text":"full signature: def plot_ls( self, runnb, lsnb, histnames=None, histlabel=None, recohist=None, recohistlabel='Reconstruction', refhists=None, refhistslabel='Reference histograms', refhiststransparency=None, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their references and/or their reconstruction note: so far only for 1D histograms. case of 2D histograms requires different plotting method since they cannot be clearly overlaid. if a HistStruct contains both 1D and 2D histograms, the 1D histograms must be selected with the histnames argument. input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of histogram types to plot (default: all) - histlabel: legend entry for the histogram (default: run and lumisection number) - recohist: dict matching histogram names to reconstructed histograms notes: - 'reconstructed histograms' refers to e.g. autoencoder or NMF reconstructions; some models (e.g. simply looking at histogram moments) might not have this kind of reconstruction - in principle one histogram per key is expected, but still the the shape must be 2D (i.e. (1,nbins)) - in case recohist is set to 'auto', the reconstruction is calculated on the fly for the input histograms - recohistlabel: legend entry for the reco histograms - refhists: dict matching histogram names to reference histograms notes: - multiple histograms (i.e. a 2D array) per key are expected; in case there is only one reference histogram, it must be reshaped into (1,nbins) - refhistslabel: legend entry for the reference histograms - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets","title":"&#10551; plot_ls"},{"location":"src/HistStruct/#plot95run","text":"full signature: def plot_run( self, runnb, masknames=None, recohist=None, recohistlabel='reco', refhists=None, refhistslabel='reference', doprint=False) comments: call plot_ls for all lumisections in a given run","title":"&#10551; plot_run"},{"location":"src/PlotStyleParser/","text":"PlotStyleParser [class] PlotStyleParser comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, jsonfile=None) comments: (no valid documentation found) \u2937 get_general_plot_options full signature: def get_general_plot_options(self) comments: (no valid documentation found) \u2937 get_general_plot_option full signature: def get_general_plot_option(self, attribute, histname=None) comments: (no valid documentation found) \u2937 get_title full signature: def get_title(self, histname=None) comments: (no valid documentation found) \u2937 get_titlesize full signature: def get_titlesize(self) comments: (no valid documentation found) \u2937 get_xaxtitle full signature: def get_xaxtitle(self, histname=None) comments: (no valid documentation found) \u2937 get_xaxtitlesize full signature: def get_xaxtitlesize(self) comments: (no valid documentation found) \u2937 get_physicalxax full signature: def get_physicalxax(self) comments: (no valid documentation found) \u2937 get_yaxtitle full signature: def get_yaxtitle(self, histname=None) comments: (no valid documentation found) \u2937 get_yaxtitlesize full signature: def get_yaxtitlesize(self) comments: (no valid documentation found) \u2937 get_ymaxfactor full signature: def get_ymaxfactor(self) comments: (no valid documentation found) \u2937 get_extratext full signature: def get_extratext(self, histname=None) comments: (no valid documentation found) \u2937 get_extratextsize full signature: def get_extratextsize(self) comments: (no valid documentation found) \u2937 get_legendsize full signature: def get_legendsize(self) comments: (no valid documentation found) \u2937 get_extracmstext full signature: def get_extracmstext(self) comments: (no valid documentation found) \u2937 get_cmstextsize full signature: def get_cmstextsize(self) comments: (no valid documentation found) \u2937 get_condtext full signature: def get_condtext(self) comments: (no valid documentation found) \u2937 get_condtextsize full signature: def get_condtextsize(self) comments: (no valid documentation found)","title":"PlotStyleParser"},{"location":"src/PlotStyleParser/#plotstyleparser","text":"","title":"PlotStyleParser"},{"location":"src/PlotStyleParser/#class-plotstyleparser","text":"comments: (no valid documentation found)","title":"[class] PlotStyleParser"},{"location":"src/PlotStyleParser/#9595init9595","text":"full signature: def __init__(self, jsonfile=None) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"src/PlotStyleParser/#get95general95plot95options","text":"full signature: def get_general_plot_options(self) comments: (no valid documentation found)","title":"&#10551; get_general_plot_options"},{"location":"src/PlotStyleParser/#get95general95plot95option","text":"full signature: def get_general_plot_option(self, attribute, histname=None) comments: (no valid documentation found)","title":"&#10551; get_general_plot_option"},{"location":"src/PlotStyleParser/#get95title","text":"full signature: def get_title(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_title"},{"location":"src/PlotStyleParser/#get95titlesize","text":"full signature: def get_titlesize(self) comments: (no valid documentation found)","title":"&#10551; get_titlesize"},{"location":"src/PlotStyleParser/#get95xaxtitle","text":"full signature: def get_xaxtitle(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_xaxtitle"},{"location":"src/PlotStyleParser/#get95xaxtitlesize","text":"full signature: def get_xaxtitlesize(self) comments: (no valid documentation found)","title":"&#10551; get_xaxtitlesize"},{"location":"src/PlotStyleParser/#get95physicalxax","text":"full signature: def get_physicalxax(self) comments: (no valid documentation found)","title":"&#10551; get_physicalxax"},{"location":"src/PlotStyleParser/#get95yaxtitle","text":"full signature: def get_yaxtitle(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_yaxtitle"},{"location":"src/PlotStyleParser/#get95yaxtitlesize","text":"full signature: def get_yaxtitlesize(self) comments: (no valid documentation found)","title":"&#10551; get_yaxtitlesize"},{"location":"src/PlotStyleParser/#get95ymaxfactor","text":"full signature: def get_ymaxfactor(self) comments: (no valid documentation found)","title":"&#10551; get_ymaxfactor"},{"location":"src/PlotStyleParser/#get95extratext","text":"full signature: def get_extratext(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_extratext"},{"location":"src/PlotStyleParser/#get95extratextsize","text":"full signature: def get_extratextsize(self) comments: (no valid documentation found)","title":"&#10551; get_extratextsize"},{"location":"src/PlotStyleParser/#get95legendsize","text":"full signature: def get_legendsize(self) comments: (no valid documentation found)","title":"&#10551; get_legendsize"},{"location":"src/PlotStyleParser/#get95extracmstext","text":"full signature: def get_extracmstext(self) comments: (no valid documentation found)","title":"&#10551; get_extracmstext"},{"location":"src/PlotStyleParser/#get95cmstextsize","text":"full signature: def get_cmstextsize(self) comments: (no valid documentation found)","title":"&#10551; get_cmstextsize"},{"location":"src/PlotStyleParser/#get95condtext","text":"full signature: def get_condtext(self) comments: (no valid documentation found)","title":"&#10551; get_condtext"},{"location":"src/PlotStyleParser/#get95condtextsize","text":"full signature: def get_condtextsize(self) comments: (no valid documentation found)","title":"&#10551; get_condtextsize"},{"location":"src/classifiers/AutoEncoder/","text":"AutoEncoder Histogram classfier based on the MSE of an autoencoder reconstruction The AutoEncoder derives from the generic HistogramClassifier. For this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. In essence, it is just a wrapper for a tensorflow model. [class] AutoEncoder comments: histogram classfier based on the MSE of an autoencoder reconstruction the AutoEncoder derives from the generic HistogramClassifier. for this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. in essence, it is just a wrapper for a tensorflow model. \u2937 __init__ full signature: def __init__( self, model=None, modelpath=None ) comments: intializer from a tensorflow model input arguments: - model: a valid tensorflow model; it does not have to be trained already, the AutoEncoder.train function will take care of this. - modelpath: path to a stored tensorflow model, it does not have to be trained already, the AutoEncoder.train function will take care of this. note: model and modelpath are alternative options, they should not both be used simultaneously. \u2937 train full signature: def train( self, histograms, doplot=True, epochs=10, batch_size=500, shuffle=False, verbose=1, validation_split=0.1, **kwargs ) comments: train the model on a given set of input histograms input arguments: - histograms: set of training histograms, a numpy array of shape (nhistograms,nbins) - doplot: boolean whether to make a plot of the loss value - others: see the keras fit function - kwargs: additional arguments passed down to keras fit function \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their autoencoder reconstruction \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: return the autoencoder reconstruction of a set of histograms \u2937 save full signature: def save( self, path ) comments: save the underlying tensorflow model to a tensorflow SavedModel or H5 format. note: depending on the extension specified in path, the SavedModel or H5 format is chosen, see https://www.tensorflow.org/guide/keras/save_and_serialize \u2937 load full signature: def load( self, path, **kwargs ) comments: get an AutoEncoder instance from a saved tensorflow SavedModel or H5 file [class] classifier = AutoEncoder comments: (no valid documentation found)","title":"AutoEncoder"},{"location":"src/classifiers/AutoEncoder/#autoencoder","text":"Histogram classfier based on the MSE of an autoencoder reconstruction The AutoEncoder derives from the generic HistogramClassifier. For this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. In essence, it is just a wrapper for a tensorflow model.","title":"AutoEncoder"},{"location":"src/classifiers/AutoEncoder/#class-autoencoder","text":"comments: histogram classfier based on the MSE of an autoencoder reconstruction the AutoEncoder derives from the generic HistogramClassifier. for this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. in essence, it is just a wrapper for a tensorflow model.","title":"[class] AutoEncoder"},{"location":"src/classifiers/AutoEncoder/#9595init9595","text":"full signature: def __init__( self, model=None, modelpath=None ) comments: intializer from a tensorflow model input arguments: - model: a valid tensorflow model; it does not have to be trained already, the AutoEncoder.train function will take care of this. - modelpath: path to a stored tensorflow model, it does not have to be trained already, the AutoEncoder.train function will take care of this. note: model and modelpath are alternative options, they should not both be used simultaneously.","title":"&#10551; __init__"},{"location":"src/classifiers/AutoEncoder/#train","text":"full signature: def train( self, histograms, doplot=True, epochs=10, batch_size=500, shuffle=False, verbose=1, validation_split=0.1, **kwargs ) comments: train the model on a given set of input histograms input arguments: - histograms: set of training histograms, a numpy array of shape (nhistograms,nbins) - doplot: boolean whether to make a plot of the loss value - others: see the keras fit function - kwargs: additional arguments passed down to keras fit function","title":"&#10551; train"},{"location":"src/classifiers/AutoEncoder/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their autoencoder reconstruction","title":"&#10551; evaluate"},{"location":"src/classifiers/AutoEncoder/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: return the autoencoder reconstruction of a set of histograms","title":"&#10551; reconstruct"},{"location":"src/classifiers/AutoEncoder/#save","text":"full signature: def save( self, path ) comments: save the underlying tensorflow model to a tensorflow SavedModel or H5 format. note: depending on the extension specified in path, the SavedModel or H5 format is chosen, see https://www.tensorflow.org/guide/keras/save_and_serialize","title":"&#10551; save"},{"location":"src/classifiers/AutoEncoder/#load","text":"full signature: def load( self, path, **kwargs ) comments: get an AutoEncoder instance from a saved tensorflow SavedModel or H5 file","title":"&#10551; load"},{"location":"src/classifiers/AutoEncoder/#class-classifier-autoencoder","text":"comments: (no valid documentation found)","title":"[class] classifier = AutoEncoder"},{"location":"src/classifiers/HistogramClassifier/","text":"HistogramClassifier Abstract base class for histogram classifying objects Note that all concrete histogram classifiers must inherit from HistogramClassifier! A HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. How to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples! [class] HistogramClassifier comments: abstract base class for histogram classifying objects note that all concrete histogram classifiers must inherit from HistogramClassifier! a HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. how to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples! \u2937 __init__ full signature: def __init__( self ) comments: empty intializer this is an @abstractmethod and must be overridden in any concrete deriving class! \u2937 train full signature: def train( self, histograms ) comments: train the classifier on a set of input histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be none. \u2937 evaluate full signature: def evaluate( self, histograms ) comments: main function used to evaluate a set of histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be a 1D numpy array of shape (nhists), one number per histogram. \u2937 save full signature: def save( self, path ) comments: save a classifier to disk specific implementation in concrete classes, here only path creation \u2937 load full signature: def load( self, path ) comments: load a classifier object from disk specific implementation in concrete classes, here only path checking","title":"HistogramClassifier"},{"location":"src/classifiers/HistogramClassifier/#histogramclassifier","text":"Abstract base class for histogram classifying objects Note that all concrete histogram classifiers must inherit from HistogramClassifier! A HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. How to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples!","title":"HistogramClassifier"},{"location":"src/classifiers/HistogramClassifier/#class-histogramclassifier","text":"comments: abstract base class for histogram classifying objects note that all concrete histogram classifiers must inherit from HistogramClassifier! a HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. how to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples!","title":"[class] HistogramClassifier"},{"location":"src/classifiers/HistogramClassifier/#9595init9595","text":"full signature: def __init__( self ) comments: empty intializer this is an @abstractmethod and must be overridden in any concrete deriving class!","title":"&#10551; __init__"},{"location":"src/classifiers/HistogramClassifier/#train","text":"full signature: def train( self, histograms ) comments: train the classifier on a set of input histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be none.","title":"&#10551; train"},{"location":"src/classifiers/HistogramClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: main function used to evaluate a set of histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be a 1D numpy array of shape (nhists), one number per histogram.","title":"&#10551; evaluate"},{"location":"src/classifiers/HistogramClassifier/#save","text":"full signature: def save( self, path ) comments: save a classifier to disk specific implementation in concrete classes, here only path creation","title":"&#10551; save"},{"location":"src/classifiers/HistogramClassifier/#load","text":"full signature: def load( self, path ) comments: load a classifier object from disk specific implementation in concrete classes, here only path checking","title":"&#10551; load"},{"location":"src/classifiers/MaxPullClassifier/","text":"MaxPullClassifier Histogram classification based on maximum pull between test histogram and reference histogram. Specifically intended for 2D histograms, but should in principle work for 1D as well. Ssee static function 'pull' for definition of bin-per-bin pull and other notes. pull full signature: def pull( testhist, refhist ) comments: calculate bin-per-bin pull between two histograms bin-per-bin pull is defined here preliminarily as (testhist(bin)-refhist(bin))/sqrt(refhist(bin)) notes: - bins in the denominator where refhist is < 1 are set to one! This is for histograms with absolute counts, and they should not be normalized! - instead another normalization is applied: the test histogram is multiplied by sum(refhist)/sum(testhist) before computing the pulls input arguments: - testhist, refhist: numpy arrays of the same shape output: numpy array of same shape as testhist and refhist maxabspull full signature: def maxabspull( testhist, refhist, n=1 ) comments: calculate maximum of bin-per-bin pulls (in absolute value) between two histograms see definition of bin-per-bin pull in function pull (above) input arguments: - testhist, refhist: numpy arrays of the same shape - n: nubmer of largest pull values to average over (default: 1, just take single maximum) output: a float [class] MaxPullClassifier comments: histogram classification based on maximum pull between test histogram and reference histogram. specifically intended for 2D histograms, but should in principle work for 1D as well. see static function pull (above) for definition of bin-per-bin pull and other notes. \u2937 __init__ full signature: def __init__( self, nmaxpulls=1 ) comments: initializer input arguments: - nmaxpulls: number of largest pull values to average over (default: 1, just take single maximum) \u2937 set_nmaxpulls full signature: def set_nmaxpulls( self, nmaxpulls ) comments: set the nmaxpulls parameter (see also initializer) \u2937 train full signature: def train( self, refhist ) comments: 'train' the classifier, i.e. set the reference histogram. input arguments: - refhist: a numpy array of shape (1,nbins) or (1,nybins,nxbins) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classify the histograms based on their max bin-per-bin pull (in absolute value) with respect to a reference histogram \u2937 getpull full signature: def getpull( self, histogram ) comments: get the pull histogram for a given test histogram input arguments: histogram: a single histogram, i.e. numpy array of shape (nbins) for 1D or (nybins,nxbins) for 2D. output: numpy array of same shape as histogram containing bin-per-bin pull w.r.t. reference histogram","title":"MaxPullClassifier"},{"location":"src/classifiers/MaxPullClassifier/#maxpullclassifier","text":"Histogram classification based on maximum pull between test histogram and reference histogram. Specifically intended for 2D histograms, but should in principle work for 1D as well. Ssee static function 'pull' for definition of bin-per-bin pull and other notes.","title":"MaxPullClassifier"},{"location":"src/classifiers/MaxPullClassifier/#pull","text":"full signature: def pull( testhist, refhist ) comments: calculate bin-per-bin pull between two histograms bin-per-bin pull is defined here preliminarily as (testhist(bin)-refhist(bin))/sqrt(refhist(bin)) notes: - bins in the denominator where refhist is < 1 are set to one! This is for histograms with absolute counts, and they should not be normalized! - instead another normalization is applied: the test histogram is multiplied by sum(refhist)/sum(testhist) before computing the pulls input arguments: - testhist, refhist: numpy arrays of the same shape output: numpy array of same shape as testhist and refhist","title":"pull"},{"location":"src/classifiers/MaxPullClassifier/#maxabspull","text":"full signature: def maxabspull( testhist, refhist, n=1 ) comments: calculate maximum of bin-per-bin pulls (in absolute value) between two histograms see definition of bin-per-bin pull in function pull (above) input arguments: - testhist, refhist: numpy arrays of the same shape - n: nubmer of largest pull values to average over (default: 1, just take single maximum) output: a float","title":"maxabspull"},{"location":"src/classifiers/MaxPullClassifier/#class-maxpullclassifier","text":"comments: histogram classification based on maximum pull between test histogram and reference histogram. specifically intended for 2D histograms, but should in principle work for 1D as well. see static function pull (above) for definition of bin-per-bin pull and other notes.","title":"[class] MaxPullClassifier"},{"location":"src/classifiers/MaxPullClassifier/#9595init9595","text":"full signature: def __init__( self, nmaxpulls=1 ) comments: initializer input arguments: - nmaxpulls: number of largest pull values to average over (default: 1, just take single maximum)","title":"&#10551; __init__"},{"location":"src/classifiers/MaxPullClassifier/#set95nmaxpulls","text":"full signature: def set_nmaxpulls( self, nmaxpulls ) comments: set the nmaxpulls parameter (see also initializer)","title":"&#10551; set_nmaxpulls"},{"location":"src/classifiers/MaxPullClassifier/#train","text":"full signature: def train( self, refhist ) comments: 'train' the classifier, i.e. set the reference histogram. input arguments: - refhist: a numpy array of shape (1,nbins) or (1,nybins,nxbins)","title":"&#10551; train"},{"location":"src/classifiers/MaxPullClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classify the histograms based on their max bin-per-bin pull (in absolute value) with respect to a reference histogram","title":"&#10551; evaluate"},{"location":"src/classifiers/MaxPullClassifier/#getpull","text":"full signature: def getpull( self, histogram ) comments: get the pull histogram for a given test histogram input arguments: histogram: a single histogram, i.e. numpy array of shape (nbins) for 1D or (nybins,nxbins) for 2D. output: numpy array of same shape as histogram containing bin-per-bin pull w.r.t. reference histogram","title":"&#10551; getpull"},{"location":"src/classifiers/NMFClassifier/","text":"NMFClassifier Histogram classification based on nonnegative matrix factorization Specifically intended for 2D histograms, but should in principle work for 1D as well. It is basically a wrapper for a sklearn.decomposition.NMF instance. [class] NMFClassifier comments: histogram classification based on nonnegative matrix factorization specifically intended for 2D histograms, but should in principle work for 1D as well. it is basically a wrapper for a sklearn.decomposition.NMF instance. \u2937 __init__ full signature: def __init__( self, ncomponents=5, loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of NMF components (aka clusters aka basis vectors) to use in the decomposition - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.NMF \u2937 train full signature: def train( self, histograms ) comments: train the NMF model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a NMF model \u2937 set_nmax full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation \u2937 set_loss_type full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) \u2937 get_components full signature: def get_components( self ) comments: return the NMF components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins) \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: return the NMF reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"NMFClassifier"},{"location":"src/classifiers/NMFClassifier/#nmfclassifier","text":"Histogram classification based on nonnegative matrix factorization Specifically intended for 2D histograms, but should in principle work for 1D as well. It is basically a wrapper for a sklearn.decomposition.NMF instance.","title":"NMFClassifier"},{"location":"src/classifiers/NMFClassifier/#class-nmfclassifier","text":"comments: histogram classification based on nonnegative matrix factorization specifically intended for 2D histograms, but should in principle work for 1D as well. it is basically a wrapper for a sklearn.decomposition.NMF instance.","title":"[class] NMFClassifier"},{"location":"src/classifiers/NMFClassifier/#9595init9595","text":"full signature: def __init__( self, ncomponents=5, loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of NMF components (aka clusters aka basis vectors) to use in the decomposition - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.NMF","title":"&#10551; __init__"},{"location":"src/classifiers/NMFClassifier/#train","text":"full signature: def train( self, histograms ) comments: train the NMF model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a NMF model","title":"&#10551; train"},{"location":"src/classifiers/NMFClassifier/#set95nmax","text":"full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation","title":"&#10551; set_nmax"},{"location":"src/classifiers/NMFClassifier/#set95loss95type","text":"full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error)","title":"&#10551; set_loss_type"},{"location":"src/classifiers/NMFClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; evaluate"},{"location":"src/classifiers/NMFClassifier/#get95components","text":"full signature: def get_components( self ) comments: return the NMF components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins)","title":"&#10551; get_components"},{"location":"src/classifiers/NMFClassifier/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: return the NMF reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; reconstruct"},{"location":"src/classifiers/PCAClassifier/","text":"PCAClassifier Histogram classification based on principal component analysis It is basically a wrapper for a sklearn.decomposition.PCA instance. [class] PCAClassifier comments: histogram classification based on principal component analysis it is basically a wrapper for a sklearn.decomposition.PCA instance. \u2937 __init__ full signature: def __init__( self, ncomponents=None, svd_solver='auto', loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of PCA components (aka clusters aka basis vectors) to use in the decomposition - svd_solver: solver method to extract the PCA components note: both ncomponents and svd_solver are arguments passed down to sklearn.decomposition.PCA, see https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.PCA \u2937 train full signature: def train( self, histograms ) comments: train the PCA model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a PCA model \u2937 set_nmax full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation \u2937 set_loss_type full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) \u2937 get_components full signature: def get_components( self ) comments: return the PCA components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins) \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: return the PCA reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"PCAClassifier"},{"location":"src/classifiers/PCAClassifier/#pcaclassifier","text":"Histogram classification based on principal component analysis It is basically a wrapper for a sklearn.decomposition.PCA instance.","title":"PCAClassifier"},{"location":"src/classifiers/PCAClassifier/#class-pcaclassifier","text":"comments: histogram classification based on principal component analysis it is basically a wrapper for a sklearn.decomposition.PCA instance.","title":"[class] PCAClassifier"},{"location":"src/classifiers/PCAClassifier/#9595init9595","text":"full signature: def __init__( self, ncomponents=None, svd_solver='auto', loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of PCA components (aka clusters aka basis vectors) to use in the decomposition - svd_solver: solver method to extract the PCA components note: both ncomponents and svd_solver are arguments passed down to sklearn.decomposition.PCA, see https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.PCA","title":"&#10551; __init__"},{"location":"src/classifiers/PCAClassifier/#train","text":"full signature: def train( self, histograms ) comments: train the PCA model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a PCA model","title":"&#10551; train"},{"location":"src/classifiers/PCAClassifier/#set95nmax","text":"full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation","title":"&#10551; set_nmax"},{"location":"src/classifiers/PCAClassifier/#set95loss95type","text":"full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error)","title":"&#10551; set_loss_type"},{"location":"src/classifiers/PCAClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; evaluate"},{"location":"src/classifiers/PCAClassifier/#get95components","text":"full signature: def get_components( self ) comments: return the PCA components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins)","title":"&#10551; get_components"},{"location":"src/classifiers/PCAClassifier/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: return the PCA reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; reconstruct"},{"location":"src/classifiers/TemplateBasedClassifier/","text":"TemplateBasedClassifier Histogram classifier based on a direct comparison with templates (i.e. reference histograms) mseTopN_templates full signature: def mseTopN_templates( histograms, templates, n=-1 ) comments: calculate the mse between each histogram in histograms and each histogram in templates input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 2D numpy array of shape (nhistograms,ntemplates) holding the mseTopN between each mseTopN_min full signature: def mseTopN_min( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the minimum input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the minimum mseTopN for each histogram mseTop10_min full signature: def mseTop10_min( histograms, templates ) comments: special case of above with n=10 mseTopN_avg full signature: def mseTopN_avg( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the average input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the average mseTopN for each histogram mseTop10_avg full signature: def mseTop10_avg( histograms, templates ) comments: special case of above with n=10 [class] TemplateBasedClassifier comments: histogram classifier based on a direct comparison with templates (i.e. reference histograms) \u2937 __init__ full signature: def __init__( self, comparemethod='minmse' ) comments: initializer input arguments: - comparemethod: string representing the method by which to compare a histogram with a set of templates currently supported methods are: - minmse: minimum mean square error between histogram and all templates - avgmse: average mean square error between histogram and all templates \u2937 train full signature: def train( self, templates ) comments: 'train' the classifier, i.e. set the templates (reference histograms) input arguments: - templates: a 2D numpy array of shape (nhistograms,nbins) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their deviation from templates","title":"TemplateBasedClassifier"},{"location":"src/classifiers/TemplateBasedClassifier/#templatebasedclassifier","text":"Histogram classifier based on a direct comparison with templates (i.e. reference histograms)","title":"TemplateBasedClassifier"},{"location":"src/classifiers/TemplateBasedClassifier/#msetopn95templates","text":"full signature: def mseTopN_templates( histograms, templates, n=-1 ) comments: calculate the mse between each histogram in histograms and each histogram in templates input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 2D numpy array of shape (nhistograms,ntemplates) holding the mseTopN between each","title":"mseTopN_templates"},{"location":"src/classifiers/TemplateBasedClassifier/#msetopn95min","text":"full signature: def mseTopN_min( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the minimum input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the minimum mseTopN for each histogram","title":"mseTopN_min"},{"location":"src/classifiers/TemplateBasedClassifier/#msetop1095min","text":"full signature: def mseTop10_min( histograms, templates ) comments: special case of above with n=10","title":"mseTop10_min"},{"location":"src/classifiers/TemplateBasedClassifier/#msetopn95avg","text":"full signature: def mseTopN_avg( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the average input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the average mseTopN for each histogram","title":"mseTopN_avg"},{"location":"src/classifiers/TemplateBasedClassifier/#msetop1095avg","text":"full signature: def mseTop10_avg( histograms, templates ) comments: special case of above with n=10","title":"mseTop10_avg"},{"location":"src/classifiers/TemplateBasedClassifier/#class-templatebasedclassifier","text":"comments: histogram classifier based on a direct comparison with templates (i.e. reference histograms)","title":"[class] TemplateBasedClassifier"},{"location":"src/classifiers/TemplateBasedClassifier/#9595init9595","text":"full signature: def __init__( self, comparemethod='minmse' ) comments: initializer input arguments: - comparemethod: string representing the method by which to compare a histogram with a set of templates currently supported methods are: - minmse: minimum mean square error between histogram and all templates - avgmse: average mean square error between histogram and all templates","title":"&#10551; __init__"},{"location":"src/classifiers/TemplateBasedClassifier/#train","text":"full signature: def train( self, templates ) comments: 'train' the classifier, i.e. set the templates (reference histograms) input arguments: - templates: a 2D numpy array of shape (nhistograms,nbins)","title":"&#10551; train"},{"location":"src/classifiers/TemplateBasedClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their deviation from templates","title":"&#10551; evaluate"},{"location":"src/cloudfitters/CloudFitter/","text":"CloudFitter Abstract base class for all point cloud fitting algorithms Note that all concrete point cloud fitters must inherit from CloudFitter! How to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples! [class] CloudFitter comments: abstract base class for all point cloud fitting algorithms note that all concrete point cloud fitters must inherit from CloudFitter! how to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples! \u2937 __init__ full signature: def __init__( self, points ) comments: default intializer this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - points: 2D numpy array of shape (npoints,ndims) \u2937 pdf full signature: def pdf( self, points ) comments: evaluate the pdf (probability density function) at given points this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - points: a 2D numpy array of shape (npoints,ndims) output: a 1D array of shape (npoints)","title":"CloudFitter"},{"location":"src/cloudfitters/CloudFitter/#cloudfitter","text":"Abstract base class for all point cloud fitting algorithms Note that all concrete point cloud fitters must inherit from CloudFitter! How to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples!","title":"CloudFitter"},{"location":"src/cloudfitters/CloudFitter/#class-cloudfitter","text":"comments: abstract base class for all point cloud fitting algorithms note that all concrete point cloud fitters must inherit from CloudFitter! how to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples!","title":"[class] CloudFitter"},{"location":"src/cloudfitters/CloudFitter/#9595init9595","text":"full signature: def __init__( self, points ) comments: default intializer this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - points: 2D numpy array of shape (npoints,ndims)","title":"&#10551; __init__"},{"location":"src/cloudfitters/CloudFitter/#pdf","text":"full signature: def pdf( self, points ) comments: evaluate the pdf (probability density function) at given points this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - points: a 2D numpy array of shape (npoints,ndims) output: a 1D array of shape (npoints)","title":"&#10551; pdf"},{"location":"src/cloudfitters/ExponentialFitter/","text":"ExponentialFitter Class for fitting an exponential distribution to a point cloud An exponential distribution in N dimensions is fully determined by an N-dimensional vector, representing the N-dimensional decay parameter (or lambda parameter) of the distribution. [class] ExponentialFitter comments: class for fitting an exponential distribution to a point cloud parameters - l: multidimensional lambda parameter of exponential \u2937 __init__ full signature: def __init__(self, points) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points","title":"ExponentialFitter"},{"location":"src/cloudfitters/ExponentialFitter/#exponentialfitter","text":"Class for fitting an exponential distribution to a point cloud An exponential distribution in N dimensions is fully determined by an N-dimensional vector, representing the N-dimensional decay parameter (or lambda parameter) of the distribution.","title":"ExponentialFitter"},{"location":"src/cloudfitters/ExponentialFitter/#class-exponentialfitter","text":"comments: class for fitting an exponential distribution to a point cloud parameters - l: multidimensional lambda parameter of exponential","title":"[class] ExponentialFitter"},{"location":"src/cloudfitters/ExponentialFitter/#9595init9595","text":"full signature: def __init__(self, points) comments: constructor input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; __init__"},{"location":"src/cloudfitters/ExponentialFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/GaussianKdeFitter/","text":"GaussianKdeFitter Class for fitting a gaussian kernel density to a point cloud Basically a wrapper for scipy.stats.gaussian_kde. A gaussian kernel density can be thought of as a sum of little (potentially multidimensional) gaussians, each one centered at one of the points in the cloud. Hence, the resulting distribution is a sort of smoothed version of the discrete point cloud. [class] GaussianKdeFitter comments: class for fitting a gaussian kernel density to a point cloud basically a wrapper for scipy.stats.gaussian_kde. parameters - kernel: scipy.stats.gaussian_kde object - cov: covariance matrix (use np.cov for now, maybe later replace by internal kernel.covariance) \u2937 __init__ full signature: def __init__(self, points, bw_method='scott', bw_scott_factor=None) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) - bw_method: method to calculate the bandwidth of the gaussians, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html - bw_scott_factor: additional multiplication factor applied to bandwidth in case it is set to 'scott' \u2937 pdf full signature: def pdf(self,points) comments: get pdf at points","title":"GaussianKdeFitter"},{"location":"src/cloudfitters/GaussianKdeFitter/#gaussiankdefitter","text":"Class for fitting a gaussian kernel density to a point cloud Basically a wrapper for scipy.stats.gaussian_kde. A gaussian kernel density can be thought of as a sum of little (potentially multidimensional) gaussians, each one centered at one of the points in the cloud. Hence, the resulting distribution is a sort of smoothed version of the discrete point cloud.","title":"GaussianKdeFitter"},{"location":"src/cloudfitters/GaussianKdeFitter/#class-gaussiankdefitter","text":"comments: class for fitting a gaussian kernel density to a point cloud basically a wrapper for scipy.stats.gaussian_kde. parameters - kernel: scipy.stats.gaussian_kde object - cov: covariance matrix (use np.cov for now, maybe later replace by internal kernel.covariance)","title":"[class] GaussianKdeFitter"},{"location":"src/cloudfitters/GaussianKdeFitter/#9595init9595","text":"full signature: def __init__(self, points, bw_method='scott', bw_scott_factor=None) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) - bw_method: method to calculate the bandwidth of the gaussians, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html - bw_scott_factor: additional multiplication factor applied to bandwidth in case it is set to 'scott'","title":"&#10551; __init__"},{"location":"src/cloudfitters/GaussianKdeFitter/#pdf","text":"full signature: def pdf(self,points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/HyperRectangleFitter/","text":"HyperRectangleFitter Simple fitter making a hard cut in each dimension calculate_cut_values full signature: def calculate_cut_values( values, quantile, side='both' ) comments: calculate the appropriate cut values to discard a given quantile of values input arguments: - values: a 1D numpy array - quantile: quantile of values to discard, a float between 0 and 1 (or between 0 and 0.5 for side='both') - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end. returns: - a tuple of shape (lower cut, upper cut), with None entries if not applicable [class] HyperRectangleFitter comments: Simple fitter making a hard cut in each dimension \u2937 __init__ full signature: def __init__(self, points, quantiles=0, side='both', verbose=False ) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) - quantiles: quantiles of values to discard. can either be a float between 0 and 1 (applied in all dimensions), or a list of such floats with same length as number of dimensions in points. (note: for side='both', quantiles above 0.5 will discard everything) - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end. \u2937 apply_cuts full signature: def apply_cuts(self, point) comments: apply the cuts to a point and return whether it passes them input arguments: - point: a 1D numpy array of shape (ndims,) returns: - boolean \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points note that the pdf is either 0 (does not pass cuts) or 1 (passes cuts)","title":"HyperRectangleFitter"},{"location":"src/cloudfitters/HyperRectangleFitter/#hyperrectanglefitter","text":"Simple fitter making a hard cut in each dimension","title":"HyperRectangleFitter"},{"location":"src/cloudfitters/HyperRectangleFitter/#calculate95cut95values","text":"full signature: def calculate_cut_values( values, quantile, side='both' ) comments: calculate the appropriate cut values to discard a given quantile of values input arguments: - values: a 1D numpy array - quantile: quantile of values to discard, a float between 0 and 1 (or between 0 and 0.5 for side='both') - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end. returns: - a tuple of shape (lower cut, upper cut), with None entries if not applicable","title":"calculate_cut_values"},{"location":"src/cloudfitters/HyperRectangleFitter/#class-hyperrectanglefitter","text":"comments: Simple fitter making a hard cut in each dimension","title":"[class] HyperRectangleFitter"},{"location":"src/cloudfitters/HyperRectangleFitter/#9595init9595","text":"full signature: def __init__(self, points, quantiles=0, side='both', verbose=False ) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) - quantiles: quantiles of values to discard. can either be a float between 0 and 1 (applied in all dimensions), or a list of such floats with same length as number of dimensions in points. (note: for side='both', quantiles above 0.5 will discard everything) - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end.","title":"&#10551; __init__"},{"location":"src/cloudfitters/HyperRectangleFitter/#apply95cuts","text":"full signature: def apply_cuts(self, point) comments: apply the cuts to a point and return whether it passes them input arguments: - point: a 1D numpy array of shape (ndims,) returns: - boolean","title":"&#10551; apply_cuts"},{"location":"src/cloudfitters/HyperRectangleFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points note that the pdf is either 0 (does not pass cuts) or 1 (passes cuts)","title":"&#10551; pdf"},{"location":"src/cloudfitters/LogNormalFitter/","text":"LogNormalFitter Class for fitting a log-normal distribution to a point cloud A log-normal distribution is constructed by fitting a normal distribution to the logarithm of the point coordinates. [class] LogNormalFitter comments: class for fitting a log-normal distribution to a point cloud parameters: - mean: multidim mean of underlying normal - cov: multidim covariance matrix of underlying normal - mvn: scipy.stats multivariate_normal object built from the mean and cov \u2937 __init__ full signature: def __init__(self,points) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) \u2937 pdf full signature: def pdf(self,points) comments: get pdf at points","title":"LogNormalFitter"},{"location":"src/cloudfitters/LogNormalFitter/#lognormalfitter","text":"Class for fitting a log-normal distribution to a point cloud A log-normal distribution is constructed by fitting a normal distribution to the logarithm of the point coordinates.","title":"LogNormalFitter"},{"location":"src/cloudfitters/LogNormalFitter/#class-lognormalfitter","text":"comments: class for fitting a log-normal distribution to a point cloud parameters: - mean: multidim mean of underlying normal - cov: multidim covariance matrix of underlying normal - mvn: scipy.stats multivariate_normal object built from the mean and cov","title":"[class] LogNormalFitter"},{"location":"src/cloudfitters/LogNormalFitter/#9595init9595","text":"full signature: def __init__(self,points) comments: constructor input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; __init__"},{"location":"src/cloudfitters/LogNormalFitter/#pdf","text":"full signature: def pdf(self,points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/SeminormalFitter/","text":"SeminormalFitter Class for fitting a 'seminormal' distribution to a point cloud This is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin. [class] SeminormalFitter comments: class for fitting a 'seminormal' distribution to a point cloud this is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin. parameters - cov: multidim covariance matrix of normal distribution - mvn: scipy.stats multivariate_normal object built from the cov \u2937 __init__ full signature: def __init__(self,points) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) note: points can also be an array or list with length 0, in that case the object is initialized empty. use this followed by the 'load' method to load a previously saved fit! \u2937 pdf full signature: def pdf(self,points) comments: get pdf at points \u2937 save full signature: def save(self,path) comments: save the covariance matrix as a .npy file specified by path \u2937 load full signature: def load(self,path) comments: load a covariance matrix from a .npy file specified by path and build the fit from it","title":"SeminormalFitter"},{"location":"src/cloudfitters/SeminormalFitter/#seminormalfitter","text":"Class for fitting a 'seminormal' distribution to a point cloud This is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin.","title":"SeminormalFitter"},{"location":"src/cloudfitters/SeminormalFitter/#class-seminormalfitter","text":"comments: class for fitting a 'seminormal' distribution to a point cloud this is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin. parameters - cov: multidim covariance matrix of normal distribution - mvn: scipy.stats multivariate_normal object built from the cov","title":"[class] SeminormalFitter"},{"location":"src/cloudfitters/SeminormalFitter/#9595init9595","text":"full signature: def __init__(self,points) comments: constructor input arguments: - points: a np array of shape (npoints,ndims) note: points can also be an array or list with length 0, in that case the object is initialized empty. use this followed by the 'load' method to load a previously saved fit!","title":"&#10551; __init__"},{"location":"src/cloudfitters/SeminormalFitter/#pdf","text":"full signature: def pdf(self,points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/SeminormalFitter/#save","text":"full signature: def save(self,path) comments: save the covariance matrix as a .npy file specified by path","title":"&#10551; save"},{"location":"src/cloudfitters/SeminormalFitter/#load","text":"full signature: def load(self,path) comments: load a covariance matrix from a .npy file specified by path and build the fit from it","title":"&#10551; load"},{"location":"utils/","text":"Collection of utility functions","title":"README"},{"location":"utils/autoencoder_utils/","text":"autoencoder utils Utilities related to the training and evaluation of autoencoder models with keras The functionality in this script includes: - definition of loss functions (several flavours of MSE or chi-squared) - calculating and plotting ROC curves and confusion matrices - definition of very simple ready-to-use keras model architectures mseTop10 full signature: def mseTop10(y_true, y_pred) comments: MSE top 10 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - mean squared error between y_true and y_pred, where only the 10 bins with largest squared error are taken into account. if y_true and y_pred are 2D arrays, this function returns 1D array (mseTop10 for each histogram) mseTop10Raw full signature: def mseTop10Raw(y_true, y_pred) comments: same as mseTop10 but without using tf or K the version including tf or K seemed to cause randomly dying kernels, no clear reason could be found, but it was solved using this loss function instead. verified that it gives exactly the same output as the function above on some random arrays. contrary to mseTop10, this function only works for arrays with 2D shapes (so shape (nhists,nbins)), not for (nbins,). mseTopNRaw full signature: def mseTopNRaw(y_true, y_pred, n=10) comments: generalization of mseTop10Raw to any number of bins to take into account note: now generalized to also work for 2D histograms, i.e. arrays of shape (nhists,nybins,nxbins)! hence this is the most general method and preferred above mseTop10 and mseTop10Raw, which are only kept for reference input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for averaging output: numpy array of shape (nhists) chiSquared full signature: def chiSquared(y_true, y_pred) comments: chi2 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - relative mean squared error between y_true and y_pred, if y_true and y_pred are 2D arrays, this function returns 1D array (chiSquared for each histogram) chiSquaredTopNRaw full signature: def chiSquaredTopNRaw(y_true, y_pred, n=10) comments: generalization of chiSquared to any number of bins to take into account note: should work for 2D histograms as well (i.e. arrays of shape (nhistograms,nybins,nxbins)), but not yet tested! input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for summing output: numpy array of shape (nhists) calculate_roc full signature: def calculate_roc(scores, labels, scoreax) comments: calculate a roc curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - scoreax is an array of score thresholds for which to compute the signal and background efficiency, assumed to be sorted in increasing order (i.e. from loose to tight) output: - tuple of two np arrays (signal efficiency and background efficiency) get_roc full signature: def get_roc(scores, labels, mode='lin', npoints=100, doprint=False, doplot=True, plotmode='classic', doshow=True) comments: make a ROC curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - mode: how to determine the points where to calculate signal and background efficiencies; options are: - 'lin': np.linspace between min and max score - 'geom': np. geomspace between min and max score - 'full': one point per score instance - npoints: number of points where to calculate the signal and background efficiencies (ignored if mode is 'full') - doprint: boolean whether to print score thresholds and corresponding signal and background efficiencies - doplot: boolean whether to make a plot or simply return the auc. - plotmode: how to plot the roc curve; options are: - 'classic' = signal efficiency afo background efficiency get_roc_from_hists full signature: def get_roc_from_hists(hists, labels, predicted_hists, mode='lin', npoints=100, doprint=False, doplot=True, plotmode='classic') comments: make a ROC curve without manually calculating the scores the output score is the mseTop10Raw between the histograms and their reconstruction - input arguments: - hists and predicted_hists are 2D numpy arrays of shape (nhistograms,nbins) - other arguments: see get_roc get_confusion_matrix full signature: def get_confusion_matrix(scores, labels, wp='maxauc', plotwp=True) comments: plot a confusion matrix input arguments: - scores and labels: defined in the same way as for get_roc - wp: the chosen working point (i.e. any score above wp is flagged as signal, any below is flagged as background) note: wp can be a integer or float, in which case that value will be used directly, or it can be a string in which case it will be used as the 'method' argument in get_wp! - plotwp: only relevant if wp is a string (see above), in which case plotwp will be used as the 'doplot' argument in get_wp get_confusion_matrix_from_hists full signature: def get_confusion_matrix_from_hists(hists, labels, predicted_hists, msewp=None) comments: plot a confusion matrix without manually calculating the scores the output score is the mse between the histograms and their reconstruction get_wp full signature: def get_wp(scores, labels, method='maxauc', doplot=False) comments: automatically calculate a suitable working point input arguments: - scores, labels: equally long 1d numpy arrays of predictions and true labels respectively note: in all methods, the labels are assumed to be 0 (for background) or 1 (for signal)! - method: method to calculate the working point currently supported: 'maxauc' - doplot: make a plot (if a plotting method exists for the chosen method) get_wp_maxauc full signature: def get_wp_maxauc(scores, labels, doplot=False) comments: calculate the working point corresponding to maximum pseudo-AUC (i.e. maximize the rectangular area enclosed by the working point) getautoencoder full signature: def getautoencoder(input_size,arch,act=[],opt='adam',loss=mseTop10) comments: get a trainable autoencoder model input args: - input_size: size of vector that autoencoder will operate on - arch: list of number of nodes per hidden layer (excluding input and output layer) - act: list of activations per layer (default: tanh) - opt: optimizer to use (default: adam) - loss: loss function to use (defualt: mseTop10) train_simple_autoencoder full signature: def train_simple_autoencoder(hists, nepochs=-1, modelname='', batch_size=500, shuffle=False, verbose=1, validation_split=0.1) comments: create and train a very simple keras model the model consists of one hidden layer (with half as many units as there are input bins), tanh activation, adam optimizer and mseTop10 loss. input args: - hists is a 2D numpy array of shape (nhistograms, nbins) - nepochs is the number of epochs to use (has a default value if left unspecified) - modelname is a file name to save the model in (default: model is not saved to a file) clip_scores full signature: def clip_scores( scores ) comments: clip +-inf values in scores +inf values in scores will be replaced by the maximum value (exclucing +inf) plus one -inf values in scores will be replaced by the minimim value (exclucing -inf) minus one input arguments: - scores: 1D numpy array returns - array with same length as scores with elements replaced as explained above","title":"autoencoder_utils"},{"location":"utils/autoencoder_utils/#autoencoder-utils","text":"Utilities related to the training and evaluation of autoencoder models with keras The functionality in this script includes: - definition of loss functions (several flavours of MSE or chi-squared) - calculating and plotting ROC curves and confusion matrices - definition of very simple ready-to-use keras model architectures","title":"autoencoder utils"},{"location":"utils/autoencoder_utils/#msetop10","text":"full signature: def mseTop10(y_true, y_pred) comments: MSE top 10 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - mean squared error between y_true and y_pred, where only the 10 bins with largest squared error are taken into account. if y_true and y_pred are 2D arrays, this function returns 1D array (mseTop10 for each histogram)","title":"mseTop10"},{"location":"utils/autoencoder_utils/#msetop10raw","text":"full signature: def mseTop10Raw(y_true, y_pred) comments: same as mseTop10 but without using tf or K the version including tf or K seemed to cause randomly dying kernels, no clear reason could be found, but it was solved using this loss function instead. verified that it gives exactly the same output as the function above on some random arrays. contrary to mseTop10, this function only works for arrays with 2D shapes (so shape (nhists,nbins)), not for (nbins,).","title":"mseTop10Raw"},{"location":"utils/autoencoder_utils/#msetopnraw","text":"full signature: def mseTopNRaw(y_true, y_pred, n=10) comments: generalization of mseTop10Raw to any number of bins to take into account note: now generalized to also work for 2D histograms, i.e. arrays of shape (nhists,nybins,nxbins)! hence this is the most general method and preferred above mseTop10 and mseTop10Raw, which are only kept for reference input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for averaging output: numpy array of shape (nhists)","title":"mseTopNRaw"},{"location":"utils/autoencoder_utils/#chisquared","text":"full signature: def chiSquared(y_true, y_pred) comments: chi2 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - relative mean squared error between y_true and y_pred, if y_true and y_pred are 2D arrays, this function returns 1D array (chiSquared for each histogram)","title":"chiSquared"},{"location":"utils/autoencoder_utils/#chisquaredtopnraw","text":"full signature: def chiSquaredTopNRaw(y_true, y_pred, n=10) comments: generalization of chiSquared to any number of bins to take into account note: should work for 2D histograms as well (i.e. arrays of shape (nhistograms,nybins,nxbins)), but not yet tested! input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for summing output: numpy array of shape (nhists)","title":"chiSquaredTopNRaw"},{"location":"utils/autoencoder_utils/#calculate95roc","text":"full signature: def calculate_roc(scores, labels, scoreax) comments: calculate a roc curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - scoreax is an array of score thresholds for which to compute the signal and background efficiency, assumed to be sorted in increasing order (i.e. from loose to tight) output: - tuple of two np arrays (signal efficiency and background efficiency)","title":"calculate_roc"},{"location":"utils/autoencoder_utils/#get95roc","text":"full signature: def get_roc(scores, labels, mode='lin', npoints=100, doprint=False, doplot=True, plotmode='classic', doshow=True) comments: make a ROC curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - mode: how to determine the points where to calculate signal and background efficiencies; options are: - 'lin': np.linspace between min and max score - 'geom': np. geomspace between min and max score - 'full': one point per score instance - npoints: number of points where to calculate the signal and background efficiencies (ignored if mode is 'full') - doprint: boolean whether to print score thresholds and corresponding signal and background efficiencies - doplot: boolean whether to make a plot or simply return the auc. - plotmode: how to plot the roc curve; options are: - 'classic' = signal efficiency afo background efficiency","title":"get_roc"},{"location":"utils/autoencoder_utils/#get95roc95from95hists","text":"full signature: def get_roc_from_hists(hists, labels, predicted_hists, mode='lin', npoints=100, doprint=False, doplot=True, plotmode='classic') comments: make a ROC curve without manually calculating the scores the output score is the mseTop10Raw between the histograms and their reconstruction - input arguments: - hists and predicted_hists are 2D numpy arrays of shape (nhistograms,nbins) - other arguments: see get_roc","title":"get_roc_from_hists"},{"location":"utils/autoencoder_utils/#get95confusion95matrix","text":"full signature: def get_confusion_matrix(scores, labels, wp='maxauc', plotwp=True) comments: plot a confusion matrix input arguments: - scores and labels: defined in the same way as for get_roc - wp: the chosen working point (i.e. any score above wp is flagged as signal, any below is flagged as background) note: wp can be a integer or float, in which case that value will be used directly, or it can be a string in which case it will be used as the 'method' argument in get_wp! - plotwp: only relevant if wp is a string (see above), in which case plotwp will be used as the 'doplot' argument in get_wp","title":"get_confusion_matrix"},{"location":"utils/autoencoder_utils/#get95confusion95matrix95from95hists","text":"full signature: def get_confusion_matrix_from_hists(hists, labels, predicted_hists, msewp=None) comments: plot a confusion matrix without manually calculating the scores the output score is the mse between the histograms and their reconstruction","title":"get_confusion_matrix_from_hists"},{"location":"utils/autoencoder_utils/#get95wp","text":"full signature: def get_wp(scores, labels, method='maxauc', doplot=False) comments: automatically calculate a suitable working point input arguments: - scores, labels: equally long 1d numpy arrays of predictions and true labels respectively note: in all methods, the labels are assumed to be 0 (for background) or 1 (for signal)! - method: method to calculate the working point currently supported: 'maxauc' - doplot: make a plot (if a plotting method exists for the chosen method)","title":"get_wp"},{"location":"utils/autoencoder_utils/#get95wp95maxauc","text":"full signature: def get_wp_maxauc(scores, labels, doplot=False) comments: calculate the working point corresponding to maximum pseudo-AUC (i.e. maximize the rectangular area enclosed by the working point)","title":"get_wp_maxauc"},{"location":"utils/autoencoder_utils/#getautoencoder","text":"full signature: def getautoencoder(input_size,arch,act=[],opt='adam',loss=mseTop10) comments: get a trainable autoencoder model input args: - input_size: size of vector that autoencoder will operate on - arch: list of number of nodes per hidden layer (excluding input and output layer) - act: list of activations per layer (default: tanh) - opt: optimizer to use (default: adam) - loss: loss function to use (defualt: mseTop10)","title":"getautoencoder"},{"location":"utils/autoencoder_utils/#train95simple95autoencoder","text":"full signature: def train_simple_autoencoder(hists, nepochs=-1, modelname='', batch_size=500, shuffle=False, verbose=1, validation_split=0.1) comments: create and train a very simple keras model the model consists of one hidden layer (with half as many units as there are input bins), tanh activation, adam optimizer and mseTop10 loss. input args: - hists is a 2D numpy array of shape (nhistograms, nbins) - nepochs is the number of epochs to use (has a default value if left unspecified) - modelname is a file name to save the model in (default: model is not saved to a file)","title":"train_simple_autoencoder"},{"location":"utils/autoencoder_utils/#clip95scores","text":"full signature: def clip_scores( scores ) comments: clip +-inf values in scores +inf values in scores will be replaced by the maximum value (exclucing +inf) plus one -inf values in scores will be replaced by the minimim value (exclucing -inf) minus one input arguments: - scores: 1D numpy array returns - array with same length as scores with elements replaced as explained above","title":"clip_scores"},{"location":"utils/clustering_utils/","text":"clustering utils A collection of functions used for performing clustering tasks This collection of tools is a little deprecated at this moment but kept for reference; it contains functionality for pre-filtering the histograms in the training set based on their moments (e.g. mean, rms). Note that the functions here have not been used in a long time and might need some maintenance before they work properly again. vecdist full signature: def vecdist(moments, index) comments: calculate the vectorial distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the points are considered as vectors and the point at index is the origin. with respect to this origin, the average vector before index and the average vector after index are calculated. the distance is then defined as the norm of the difference of these vectors, normalized by the norms of the individual vectors. costhetadist full signature: def costhetadist(moments, index) comments: calculate the costheta distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - this distance measure takes the cosine of the angle between the point at index and the one at index-1 (interpreted as vectors from the origin). avgnndist full signature: def avgnndist(moments, index, nn) comments: calculate average euclidean distance to neighbouring points input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances - nn: (half-) window size returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the average euclidean distance is calculated between the point at 'index' and the points at index-nn and index+nn (e.g. the nn previous and next lumisections). getavgnndist full signature: def getavgnndist(hists, nmoments, xmin, xmax, nbins, nneighbours) comments: apply avgnndist to a set of histograms filteranomalous full signature: def filteranomalous(df, nmoments=3, rmouterflow=True, rmlargest=0., doplot=True) comments: do a pre-filtering, removing the histograms with anomalous moments","title":"clustering_utils"},{"location":"utils/clustering_utils/#clustering-utils","text":"A collection of functions used for performing clustering tasks This collection of tools is a little deprecated at this moment but kept for reference; it contains functionality for pre-filtering the histograms in the training set based on their moments (e.g. mean, rms). Note that the functions here have not been used in a long time and might need some maintenance before they work properly again.","title":"clustering utils"},{"location":"utils/clustering_utils/#vecdist","text":"full signature: def vecdist(moments, index) comments: calculate the vectorial distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the points are considered as vectors and the point at index is the origin. with respect to this origin, the average vector before index and the average vector after index are calculated. the distance is then defined as the norm of the difference of these vectors, normalized by the norms of the individual vectors.","title":"vecdist"},{"location":"utils/clustering_utils/#costhetadist","text":"full signature: def costhetadist(moments, index) comments: calculate the costheta distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - this distance measure takes the cosine of the angle between the point at index and the one at index-1 (interpreted as vectors from the origin).","title":"costhetadist"},{"location":"utils/clustering_utils/#avgnndist","text":"full signature: def avgnndist(moments, index, nn) comments: calculate average euclidean distance to neighbouring points input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances - nn: (half-) window size returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the average euclidean distance is calculated between the point at 'index' and the points at index-nn and index+nn (e.g. the nn previous and next lumisections).","title":"avgnndist"},{"location":"utils/clustering_utils/#getavgnndist","text":"full signature: def getavgnndist(hists, nmoments, xmin, xmax, nbins, nneighbours) comments: apply avgnndist to a set of histograms","title":"getavgnndist"},{"location":"utils/clustering_utils/#filteranomalous","text":"full signature: def filteranomalous(df, nmoments=3, rmouterflow=True, rmlargest=0., doplot=True) comments: do a pre-filtering, removing the histograms with anomalous moments","title":"filteranomalous"},{"location":"utils/csv_utils/","text":"csv utils A collection of useful basic functions for reading and processing the input csv files. Functionality includes: - reading the raw input csv files and producing more manageable csv files (grouped per histogram type). - reading csv files into pandas dataframes and writing pandas dataframes back to csv files. Note: the functionality of these utils has been absorbed into the DataLoader class, which is now the recommended way to read the data! get_data_dirs full signature: def get_data_dirs(year='2017', eras=[], dim=1) comments: yield all data directories note that the location of the data is hard-coded; this function might break for newer or later reprocessings of the data. - year is a string, either '2017' or '2018' - era is a list containing a selection of era names (default empty list = all eras) - dim is either 1 or 2 (for 1D or 2D plots) get_csv_files full signature: def get_csv_files(inputdir) comments: yields paths to all csv files in input directory note that the output paths consist of input_dir/filename this function is only meant for 1-level down searching, i.e. the .csv files listed directly under input_dir. sort_filenames full signature: def sort_filenames(filelist) comments: sort filenames in numerical order (e.g. 2 before 10) note that the number is supposed to be in ..._<number>.<extension> format read_csv full signature: def read_csv(csv_file) comments: read csv file into pandas dataframe csv_file is the path to the csv file to be read write_csv full signature: def write_csv(dataframe,csvfilename) comments: write a dataframe to a csv file note: just a wrapper for builtin dataframe.to_csv read_and_merge_csv full signature: def read_and_merge_csv(csv_files, histnames=[], runnbs=[]) comments: read and merge list of csv files into a single df csv_files is a list of paths to files to merge into a df histnames is a list of the types of histograms to keep (default: all) runnbs is a list of run numbers to keep (default: all) write_skimmed_csv full signature: def write_skimmed_csv(histnames, year, eras=['all'], dim=1) comments: read all available data for a given year/era and make a file per histogram type input arguments: - histnames: list of histogram names for which to make a separate file - year: data-taking year (in string format) - eras: data-taking eras for which to make a separate file (in string format) use 'all' to make a file with all eras merged, i.e. a full data taking year - dim: dimension of histograms (1 or 2), needed to retrieve the correct folder containing input files output: - one csv file per year/era and per histogram type note: this function can take quite a while to run!","title":"csv_utils"},{"location":"utils/csv_utils/#csv-utils","text":"A collection of useful basic functions for reading and processing the input csv files. Functionality includes: - reading the raw input csv files and producing more manageable csv files (grouped per histogram type). - reading csv files into pandas dataframes and writing pandas dataframes back to csv files. Note: the functionality of these utils has been absorbed into the DataLoader class, which is now the recommended way to read the data!","title":"csv utils"},{"location":"utils/csv_utils/#get95data95dirs","text":"full signature: def get_data_dirs(year='2017', eras=[], dim=1) comments: yield all data directories note that the location of the data is hard-coded; this function might break for newer or later reprocessings of the data. - year is a string, either '2017' or '2018' - era is a list containing a selection of era names (default empty list = all eras) - dim is either 1 or 2 (for 1D or 2D plots)","title":"get_data_dirs"},{"location":"utils/csv_utils/#get95csv95files","text":"full signature: def get_csv_files(inputdir) comments: yields paths to all csv files in input directory note that the output paths consist of input_dir/filename this function is only meant for 1-level down searching, i.e. the .csv files listed directly under input_dir.","title":"get_csv_files"},{"location":"utils/csv_utils/#sort95filenames","text":"full signature: def sort_filenames(filelist) comments: sort filenames in numerical order (e.g. 2 before 10) note that the number is supposed to be in ..._<number>.<extension> format","title":"sort_filenames"},{"location":"utils/csv_utils/#read95csv","text":"full signature: def read_csv(csv_file) comments: read csv file into pandas dataframe csv_file is the path to the csv file to be read","title":"read_csv"},{"location":"utils/csv_utils/#write95csv","text":"full signature: def write_csv(dataframe,csvfilename) comments: write a dataframe to a csv file note: just a wrapper for builtin dataframe.to_csv","title":"write_csv"},{"location":"utils/csv_utils/#read95and95merge95csv","text":"full signature: def read_and_merge_csv(csv_files, histnames=[], runnbs=[]) comments: read and merge list of csv files into a single df csv_files is a list of paths to files to merge into a df histnames is a list of the types of histograms to keep (default: all) runnbs is a list of run numbers to keep (default: all)","title":"read_and_merge_csv"},{"location":"utils/csv_utils/#write95skimmed95csv","text":"full signature: def write_skimmed_csv(histnames, year, eras=['all'], dim=1) comments: read all available data for a given year/era and make a file per histogram type input arguments: - histnames: list of histogram names for which to make a separate file - year: data-taking year (in string format) - eras: data-taking eras for which to make a separate file (in string format) use 'all' to make a file with all eras merged, i.e. a full data taking year - dim: dimension of histograms (1 or 2), needed to retrieve the correct folder containing input files output: - one csv file per year/era and per histogram type note: this function can take quite a while to run!","title":"write_skimmed_csv"},{"location":"utils/dataframe_utils/","text":"dataframe utils A collection of useful basic functions for manipulating pandas dataframes. Functionality includes (among others): - selecting DCS-bit on data or golden json data. - selecting specific runs, lumisections, or types of histograms get_histnames full signature: def get_histnames(df) comments: get a list of (unique) histogram names present in a df df is a dataframe read from an input csv file. select_histnames full signature: def select_histnames(df, histnames) comments: keep only a subset of histograms in a df histnames is a list of histogram names to keep in the df. get_runs full signature: def get_runs(df) comments: return a list of (unique) run numbers present in a df df is a dataframe read from an input csv file. select_runs full signature: def select_runs(df, runnbs) comments: keep only a subset of runs in a df runnbs is a list of run numbers to keep in the df. get_ls full signature: def get_ls(df) comments: return a list of ls numbers present in a df note that the numbers are not required to be unique! note: no check is done on the run number! select_ls full signature: def select_ls(df, lsnbs) comments: keep only a subset of lumisection numbers in a df lsnbs is a list of lumisection numbers to keep in the df. note: no check is done on the run number! get_runsls full signature: def get_runsls(df) comments: return a dictionary with runs and lumisections in a dataframe (same format as e.g. golden json) select_json full signature: def select_json(df, jsonfile) comments: keep only lumisections that are in the given json file select_runsls full signature: def select_runsls(df, jsondict) comments: equivalent to select_json but using a pre-loaded json dict instead of a json file on disk select_golden full signature: def select_golden(df) comments: keep only golden lumisections in df select_notgolden full signature: def select_notgolden(df) comments: keep all but golden lumisections in df select_dcson full signature: def select_dcson(df) comments: keep only lumisections in df that have DCS-bit on select_dcsoff full signature: def select_dcsoff(df) comments: keep only lumisections in df that have DCS-bit off select_pixelgood full signature: def select_pixelgood(df) comments: keep only lumisections in df that are in good pixel json select_pixelbad full signature: def select_pixelbad(df) comments: keep only lumisections in df that are in bad pixel json get_highstat full signature: def get_highstat(df, entries_to_bins_ratio=100) comments: return a select object of runs and ls of histograms with high statistics select_highstat full signature: def select_highstat(df, entries_to_bins_ratio=100) comments: keep only lumisection in df with high statistics get_hist_values full signature: def get_hist_values(df) comments: same as builtin \"df['histo'].values\" but convert strings to np arrays input arguments: - df: a dataframe containing histograms (assumed to be of a single type!) note: this function works for both 1D and 2D histograms, the distinction is made based on whether or not 'Ybins' is present as a column in the dataframe update: 'Ybins' is also present for 1D histograms, but has value 1! output: a tuple containing the following elements: - np array of shape (nhists,nbins) (for 1D) or (nhists,nybins,nxbins) (for 2D) - np array of run numbers of length nhists - np array of lumisection numbers of length nhists warning: no check is done to assure that all histograms are of the same type!","title":"dataframe_utils"},{"location":"utils/dataframe_utils/#dataframe-utils","text":"A collection of useful basic functions for manipulating pandas dataframes. Functionality includes (among others): - selecting DCS-bit on data or golden json data. - selecting specific runs, lumisections, or types of histograms","title":"dataframe utils"},{"location":"utils/dataframe_utils/#get95histnames","text":"full signature: def get_histnames(df) comments: get a list of (unique) histogram names present in a df df is a dataframe read from an input csv file.","title":"get_histnames"},{"location":"utils/dataframe_utils/#select95histnames","text":"full signature: def select_histnames(df, histnames) comments: keep only a subset of histograms in a df histnames is a list of histogram names to keep in the df.","title":"select_histnames"},{"location":"utils/dataframe_utils/#get95runs","text":"full signature: def get_runs(df) comments: return a list of (unique) run numbers present in a df df is a dataframe read from an input csv file.","title":"get_runs"},{"location":"utils/dataframe_utils/#select95runs","text":"full signature: def select_runs(df, runnbs) comments: keep only a subset of runs in a df runnbs is a list of run numbers to keep in the df.","title":"select_runs"},{"location":"utils/dataframe_utils/#get95ls","text":"full signature: def get_ls(df) comments: return a list of ls numbers present in a df note that the numbers are not required to be unique! note: no check is done on the run number!","title":"get_ls"},{"location":"utils/dataframe_utils/#select95ls","text":"full signature: def select_ls(df, lsnbs) comments: keep only a subset of lumisection numbers in a df lsnbs is a list of lumisection numbers to keep in the df. note: no check is done on the run number!","title":"select_ls"},{"location":"utils/dataframe_utils/#get95runsls","text":"full signature: def get_runsls(df) comments: return a dictionary with runs and lumisections in a dataframe (same format as e.g. golden json)","title":"get_runsls"},{"location":"utils/dataframe_utils/#select95json","text":"full signature: def select_json(df, jsonfile) comments: keep only lumisections that are in the given json file","title":"select_json"},{"location":"utils/dataframe_utils/#select95runsls","text":"full signature: def select_runsls(df, jsondict) comments: equivalent to select_json but using a pre-loaded json dict instead of a json file on disk","title":"select_runsls"},{"location":"utils/dataframe_utils/#select95golden","text":"full signature: def select_golden(df) comments: keep only golden lumisections in df","title":"select_golden"},{"location":"utils/dataframe_utils/#select95notgolden","text":"full signature: def select_notgolden(df) comments: keep all but golden lumisections in df","title":"select_notgolden"},{"location":"utils/dataframe_utils/#select95dcson","text":"full signature: def select_dcson(df) comments: keep only lumisections in df that have DCS-bit on","title":"select_dcson"},{"location":"utils/dataframe_utils/#select95dcsoff","text":"full signature: def select_dcsoff(df) comments: keep only lumisections in df that have DCS-bit off","title":"select_dcsoff"},{"location":"utils/dataframe_utils/#select95pixelgood","text":"full signature: def select_pixelgood(df) comments: keep only lumisections in df that are in good pixel json","title":"select_pixelgood"},{"location":"utils/dataframe_utils/#select95pixelbad","text":"full signature: def select_pixelbad(df) comments: keep only lumisections in df that are in bad pixel json","title":"select_pixelbad"},{"location":"utils/dataframe_utils/#get95highstat","text":"full signature: def get_highstat(df, entries_to_bins_ratio=100) comments: return a select object of runs and ls of histograms with high statistics","title":"get_highstat"},{"location":"utils/dataframe_utils/#select95highstat","text":"full signature: def select_highstat(df, entries_to_bins_ratio=100) comments: keep only lumisection in df with high statistics","title":"select_highstat"},{"location":"utils/dataframe_utils/#get95hist95values","text":"full signature: def get_hist_values(df) comments: same as builtin \"df['histo'].values\" but convert strings to np arrays input arguments: - df: a dataframe containing histograms (assumed to be of a single type!) note: this function works for both 1D and 2D histograms, the distinction is made based on whether or not 'Ybins' is present as a column in the dataframe update: 'Ybins' is also present for 1D histograms, but has value 1! output: a tuple containing the following elements: - np array of shape (nhists,nbins) (for 1D) or (nhists,nybins,nxbins) (for 2D) - np array of run numbers of length nhists - np array of lumisection numbers of length nhists warning: no check is done to assure that all histograms are of the same type!","title":"get_hist_values"},{"location":"utils/generate_data_2d_utils/","text":"generate data 2d utils Extension of generate_data_utils.py towards 2D histograms goodnoise_nd full signature: def goodnoise_nd(shape, fstd=None, kmaxscale=0.25, ncomponents=3) comments: generate one sample of 'good' noise consisting of fourier components generalization of goodnoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). - kmaxscale: scale factor to limit maximum frequency (lower kmaxscale means smoother noise) note: can be a tuple with same length as shape, to scale differently in different dimensions. - ncomponents: number of random sines to add per dimension note: can be a tuple with same length as shape, to use a different number of components in different dimensions. output: - numpy array of shape detailed by shape argument containing the noise whitenoise_nd full signature: def whitenoise_nd(shape, fstd=None) comments: generate one sample of white noise (standard normally distributed, uncorrelated between bins) generalization of whitenoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). output: - numpy array of shape detailed by shape argument containing the noise random_lico_nd full signature: def random_lico_nd(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1. generalization of random_lico (see generate_data_utils) to arbitrary number of dimensions. input args: - numpy array of shape (nhists,<arbitrary number of additional dimensions>) output: - numpy array of shape (<same dimensions as input>), containing the new histogram fourier_noise_nd full signature: def fourier_noise_nd(hists, outfilename='', figname='', nresamples=1, nonnegative=True, stdfactor=15., kmaxscale=0.25, ncomponents=3) comments: apply fourier noise on random histograms with simple flat amplitude scaling. generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) - kmaxscale and ncomponents: see goodnoise_nd white_noise_nd full signature: def white_noise_nd(hists, figname='', nresamples=1, nonnegative=True, stdfactor=15.) comments: apply white noise to the histograms in hists. generalization of white_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: np array (nhists,<arbitrary number of dimensions>) containing input histograms - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise) resample_lico_nd full signature: def resample_lico_nd(hists, nresamples=1, nonnegative=True) comments: take random linear combinations of input histograms generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - nresamples: number of samples to draw - nonnegative: boolean whether to set all bins to minimum zero after applying noise note: coefficients in linear combination are always nonnegative, so this setting is superfluous is input histograms are all nonnegative","title":"generate_data_2d_utils"},{"location":"utils/generate_data_2d_utils/#generate-data-2d-utils","text":"Extension of generate_data_utils.py towards 2D histograms","title":"generate data 2d utils"},{"location":"utils/generate_data_2d_utils/#goodnoise95nd","text":"full signature: def goodnoise_nd(shape, fstd=None, kmaxscale=0.25, ncomponents=3) comments: generate one sample of 'good' noise consisting of fourier components generalization of goodnoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). - kmaxscale: scale factor to limit maximum frequency (lower kmaxscale means smoother noise) note: can be a tuple with same length as shape, to scale differently in different dimensions. - ncomponents: number of random sines to add per dimension note: can be a tuple with same length as shape, to use a different number of components in different dimensions. output: - numpy array of shape detailed by shape argument containing the noise","title":"goodnoise_nd"},{"location":"utils/generate_data_2d_utils/#whitenoise95nd","text":"full signature: def whitenoise_nd(shape, fstd=None) comments: generate one sample of white noise (standard normally distributed, uncorrelated between bins) generalization of whitenoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). output: - numpy array of shape detailed by shape argument containing the noise","title":"whitenoise_nd"},{"location":"utils/generate_data_2d_utils/#random95lico95nd","text":"full signature: def random_lico_nd(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1. generalization of random_lico (see generate_data_utils) to arbitrary number of dimensions. input args: - numpy array of shape (nhists,<arbitrary number of additional dimensions>) output: - numpy array of shape (<same dimensions as input>), containing the new histogram","title":"random_lico_nd"},{"location":"utils/generate_data_2d_utils/#fourier95noise95nd","text":"full signature: def fourier_noise_nd(hists, outfilename='', figname='', nresamples=1, nonnegative=True, stdfactor=15., kmaxscale=0.25, ncomponents=3) comments: apply fourier noise on random histograms with simple flat amplitude scaling. generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) - kmaxscale and ncomponents: see goodnoise_nd","title":"fourier_noise_nd"},{"location":"utils/generate_data_2d_utils/#white95noise95nd","text":"full signature: def white_noise_nd(hists, figname='', nresamples=1, nonnegative=True, stdfactor=15.) comments: apply white noise to the histograms in hists. generalization of white_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: np array (nhists,<arbitrary number of dimensions>) containing input histograms - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise)","title":"white_noise_nd"},{"location":"utils/generate_data_2d_utils/#resample95lico95nd","text":"full signature: def resample_lico_nd(hists, nresamples=1, nonnegative=True) comments: take random linear combinations of input histograms generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - nresamples: number of samples to draw - nonnegative: boolean whether to set all bins to minimum zero after applying noise note: coefficients in linear combination are always nonnegative, so this setting is superfluous is input histograms are all nonnegative","title":"resample_lico_nd"},{"location":"utils/generate_data_utils/","text":"generate data utils A collection of functions for artificially creating a labeled dataset. See the function documentation below for more details on the implemented methods. Also check the tutorial generate_data.ipynb for examples! goodnoise full signature: def goodnoise(nbins, fstd=None) comments: generate one sample of 'good' noise consisting of fourier components input args: - nbins: number of bins, length of noise array to be sampled - fstd: an array of length nbins used for scaling of the amplitude of the noise bin-by-bin. output: - numpy array of length nbins containing the noise badnoise full signature: def badnoise(nbins, fstd=None) comments: generate one sample of 'bad' noise consisting of fourier components (higher frequency and amplitude than 'good' noise) input args and output: simlar to goodnoise WARNING: NOT NECESSARILY REPRESENTATIVE OF ANOMALIES TO BE EXPECTED, DO NOT USE whitenoise full signature: def whitenoise(nbins, fstd=None) comments: generate one sample of white noise (uncorrelated between bins) input args and output: similar to goodnoise random_lico full signature: def random_lico(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1 input args: - numpy array of shape (nhists,nbins), the rows of which will be linearly combined output: - numpy array of shape (nbins), containing the new histogram smoother full signature: def smoother(inarray, halfwidth=1) comments: smooth the rows of a 2D array using the 2*halfwidth+1 surrounding values. mse_correlation_vector full signature: def mse_correlation_vector(hists, index) comments: calculate mse of a histogram at given index wrt all other histograms input args: - hists: numpy array of shape (nhists,nbins) containing the histograms - index: the index (must be in (0,len(hists)-1)) of the histogram in question output: - numpy array of length nhists containing mse of the indexed histogram with respect to all other histograms WARNING: can be slow if called many times on a large collection of histograms with many bins. moments_correlation_vector full signature: def moments_correlation_vector(moments, index) comments: calculate moment distance of hist at index wrt all other hists very similar to mse_correlation_vector but using histogram moments instead of full histograms for speed-up plot_data_and_gen full signature: def plot_data_and_gen(datahists, genhists, nplot=10, figname='fig.png') comments: plot a couple of random examples from data and generated histograms input arguments: - datahists, genhists: numpy arrays of shape (nhists,nbins) - nplot: integer, maximum number of examples to plot - figname: name of figure to plot plot_seed_and_gen full signature: def plot_seed_and_gen(seedhists, genhists, figname='fig.png') comments: plot seed and generated histograms input arguments: - seedhists, genhists: numpy arrays of shape (nhists,nbins) - figname: name of figure to plot plot_noise full signature: def plot_noise(noise, histstd=None, figname='fig.png') comments: plot histograms in noise (numpy array of shape (nhists,nbins)) optional argument histstd plots +- histstd as boundaries fourier_noise_on_mean full signature: def fourier_noise_on_mean(hists, outfilename='', figname='', nresamples=0, nonnegative=True) comments: apply fourier noise on the bin-per-bin mean histogram, with amplitude scaling based on bin-per-bin std histogram. input args: - hists: numpy array of shape (nhists,nbins) used for determining mean and std - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw (default: number of input histograms / 10) - nonnegative: boolean whether to set all bins to minimum zero after applying noise MOSTLY SUITABLE AS HELP FUNCTION FOR RESAMPLE_SIMILAR_FOURIER_NOISE, NOT AS GENERATOR IN ITSELF advantages: mean histogram is almost certainly 'good' because of averaging, eliminate bad histograms disadvantages: deviations from mean are small, does not model systematic shifts by lumi. fourier_noise full signature: def fourier_noise(hists, outfilename='', figname='', nresamples=1, nonnegative=True, stdfactor=15.) comments: apply fourier noise on random histograms with simple flat amplitude scaling. input args: - hists: numpy array of shape (nhists,nbins) used for seeding - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) advantages: resampled histograms will have statistically same features as original input set disadvantages: also 'bad' histograms will be resampled if included in hists upsample_hist_set full signature: def upsample_hist_set(hists, ntarget=-1, fourierstdfactor=15., figname='f') comments: wrapper for fourier_noise allowing for a fixed target number of histograms instead of a fixed resampling factor useful function for quickly generating a fixed number of resampled histograms, without bothering too much about what exact resampling technique or detailed settings would be most appropriate. input arguments: hists: input histogram set ntarget: targetted number of resampled histograms (default: equally many as in hists) fourierstdfactor: see fourier_noise white_noise full signature: def white_noise(hists, figname='', stdfactor=15.) comments: apply white noise to the histograms in hists. input args: - hists: np array (nhists,nbins) containing input histograms - figname: path to figure plotting examples (default: no plotting) - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise) resample_bin_per_bin full signature: def resample_bin_per_bin(hists, outfilename='', figname='', nresamples=0, nonnegative=True, smoothinghalfwidth=2) comments: do resampling from bin-per-bin probability distributions input args: - hists: np array (nhists,nbins) containing the histograms to draw new samples from - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw (default: 1/10 of number of input histograms) - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - smoothinghalfwidth: halfwidth of smoothing procedure to apply on the result (default: no smoothing) advantages: no arbitrary noise modeling disadvantages: bins are considered independent, shape of historams not taken into account, does not work well on small number of input histograms, does not work well on histograms with systematic shifts resample_similar_bin_per_bin full signature: def resample_similar_bin_per_bin( allhists, selhists, outfilename='', figname='', nresamples=1, nonnegative=True, keeppercentage=1.) comments: resample from bin-per-bin probability distributions, but only from similar looking histograms. input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram advantages: no assumptions on shape of noise, can handle systematic shifts in histograms disadvantages: bins are treated independently from each other resample_similar_fourier_noise full signature: def resample_similar_fourier_noise( allhists, selhists, outfilename='', figname='', nresamples=1, nonnegative=True, keeppercentage=1.) comments: apply fourier noise on mean histogram, where the mean is determined from a set of similar-looking histograms input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram advantages: most of fourier_noise_on_mean but can additionally handle shifting histograms, apart from fourier noise, also white noise can be applied. disadvantages: does not filter out odd histograms as long as enough other odd histograms look more or less similar resample_similar_lico full signature: def resample_similar_lico( allhists, selhists, outfilename='', figname='', nresamples=1, nonnegative=True, keeppercentage=1.) comments: take linear combinations of similar histograms input arguments: - allhists: 2D np array (nhists,nbins) with all available histograms, used to take linear combinations - selhists: 2D np array (nhists,nbins) with selected hists used for seeding (e.g. 'good' histograms) - outfilename: path to csv file to write result to (default: no writing) - figname: path to figure plotting examples (defautl: no plotting) - nresamples: number of combinations to make per input histogram - nonnegative: boolean whether to make all final histograms nonnegative - keeppercentage: percentage (between 0. and 100.) of histograms in allhists to use per input histogram advantages: no assumptions on noise disadvantages: sensitive to outlying histograms (more than with averaging) mc_sampling full signature: def mc_sampling(hists, nMC=10000 , nresamples=10) comments: resampling of a histogram using MC methods Drawing random points from a space defined by the range of the histogram in all axes. Points are \"accepted\" if the fall under the sampled histogram: f(x) - sampled distribution x_r, y_r -> randomly sampled point if y_r<=f(x_r), fill the new distribution at bin corresponding to x_r with weight: weight = (sum of input hist)/(#mc points accepted) this is equal to weight = (MC space volume)/(all MC points)","title":"generate_data_utils"},{"location":"utils/generate_data_utils/#generate-data-utils","text":"A collection of functions for artificially creating a labeled dataset. See the function documentation below for more details on the implemented methods. Also check the tutorial generate_data.ipynb for examples!","title":"generate data utils"},{"location":"utils/generate_data_utils/#goodnoise","text":"full signature: def goodnoise(nbins, fstd=None) comments: generate one sample of 'good' noise consisting of fourier components input args: - nbins: number of bins, length of noise array to be sampled - fstd: an array of length nbins used for scaling of the amplitude of the noise bin-by-bin. output: - numpy array of length nbins containing the noise","title":"goodnoise"},{"location":"utils/generate_data_utils/#badnoise","text":"full signature: def badnoise(nbins, fstd=None) comments: generate one sample of 'bad' noise consisting of fourier components (higher frequency and amplitude than 'good' noise) input args and output: simlar to goodnoise WARNING: NOT NECESSARILY REPRESENTATIVE OF ANOMALIES TO BE EXPECTED, DO NOT USE","title":"badnoise"},{"location":"utils/generate_data_utils/#whitenoise","text":"full signature: def whitenoise(nbins, fstd=None) comments: generate one sample of white noise (uncorrelated between bins) input args and output: similar to goodnoise","title":"whitenoise"},{"location":"utils/generate_data_utils/#random95lico","text":"full signature: def random_lico(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1 input args: - numpy array of shape (nhists,nbins), the rows of which will be linearly combined output: - numpy array of shape (nbins), containing the new histogram","title":"random_lico"},{"location":"utils/generate_data_utils/#smoother","text":"full signature: def smoother(inarray, halfwidth=1) comments: smooth the rows of a 2D array using the 2*halfwidth+1 surrounding values.","title":"smoother"},{"location":"utils/generate_data_utils/#mse95correlation95vector","text":"full signature: def mse_correlation_vector(hists, index) comments: calculate mse of a histogram at given index wrt all other histograms input args: - hists: numpy array of shape (nhists,nbins) containing the histograms - index: the index (must be in (0,len(hists)-1)) of the histogram in question output: - numpy array of length nhists containing mse of the indexed histogram with respect to all other histograms WARNING: can be slow if called many times on a large collection of histograms with many bins.","title":"mse_correlation_vector"},{"location":"utils/generate_data_utils/#moments95correlation95vector","text":"full signature: def moments_correlation_vector(moments, index) comments: calculate moment distance of hist at index wrt all other hists very similar to mse_correlation_vector but using histogram moments instead of full histograms for speed-up","title":"moments_correlation_vector"},{"location":"utils/generate_data_utils/#plot95data95and95gen","text":"full signature: def plot_data_and_gen(datahists, genhists, nplot=10, figname='fig.png') comments: plot a couple of random examples from data and generated histograms input arguments: - datahists, genhists: numpy arrays of shape (nhists,nbins) - nplot: integer, maximum number of examples to plot - figname: name of figure to plot","title":"plot_data_and_gen"},{"location":"utils/generate_data_utils/#plot95seed95and95gen","text":"full signature: def plot_seed_and_gen(seedhists, genhists, figname='fig.png') comments: plot seed and generated histograms input arguments: - seedhists, genhists: numpy arrays of shape (nhists,nbins) - figname: name of figure to plot","title":"plot_seed_and_gen"},{"location":"utils/generate_data_utils/#plot95noise","text":"full signature: def plot_noise(noise, histstd=None, figname='fig.png') comments: plot histograms in noise (numpy array of shape (nhists,nbins)) optional argument histstd plots +- histstd as boundaries","title":"plot_noise"},{"location":"utils/generate_data_utils/#fourier95noise95on95mean","text":"full signature: def fourier_noise_on_mean(hists, outfilename='', figname='', nresamples=0, nonnegative=True) comments: apply fourier noise on the bin-per-bin mean histogram, with amplitude scaling based on bin-per-bin std histogram. input args: - hists: numpy array of shape (nhists,nbins) used for determining mean and std - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw (default: number of input histograms / 10) - nonnegative: boolean whether to set all bins to minimum zero after applying noise MOSTLY SUITABLE AS HELP FUNCTION FOR RESAMPLE_SIMILAR_FOURIER_NOISE, NOT AS GENERATOR IN ITSELF advantages: mean histogram is almost certainly 'good' because of averaging, eliminate bad histograms disadvantages: deviations from mean are small, does not model systematic shifts by lumi.","title":"fourier_noise_on_mean"},{"location":"utils/generate_data_utils/#fourier95noise","text":"full signature: def fourier_noise(hists, outfilename='', figname='', nresamples=1, nonnegative=True, stdfactor=15.) comments: apply fourier noise on random histograms with simple flat amplitude scaling. input args: - hists: numpy array of shape (nhists,nbins) used for seeding - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) advantages: resampled histograms will have statistically same features as original input set disadvantages: also 'bad' histograms will be resampled if included in hists","title":"fourier_noise"},{"location":"utils/generate_data_utils/#upsample95hist95set","text":"full signature: def upsample_hist_set(hists, ntarget=-1, fourierstdfactor=15., figname='f') comments: wrapper for fourier_noise allowing for a fixed target number of histograms instead of a fixed resampling factor useful function for quickly generating a fixed number of resampled histograms, without bothering too much about what exact resampling technique or detailed settings would be most appropriate. input arguments: hists: input histogram set ntarget: targetted number of resampled histograms (default: equally many as in hists) fourierstdfactor: see fourier_noise","title":"upsample_hist_set"},{"location":"utils/generate_data_utils/#white95noise","text":"full signature: def white_noise(hists, figname='', stdfactor=15.) comments: apply white noise to the histograms in hists. input args: - hists: np array (nhists,nbins) containing input histograms - figname: path to figure plotting examples (default: no plotting) - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise)","title":"white_noise"},{"location":"utils/generate_data_utils/#resample95bin95per95bin","text":"full signature: def resample_bin_per_bin(hists, outfilename='', figname='', nresamples=0, nonnegative=True, smoothinghalfwidth=2) comments: do resampling from bin-per-bin probability distributions input args: - hists: np array (nhists,nbins) containing the histograms to draw new samples from - outfilename: path to csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples to draw (default: 1/10 of number of input histograms) - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - smoothinghalfwidth: halfwidth of smoothing procedure to apply on the result (default: no smoothing) advantages: no arbitrary noise modeling disadvantages: bins are considered independent, shape of historams not taken into account, does not work well on small number of input histograms, does not work well on histograms with systematic shifts","title":"resample_bin_per_bin"},{"location":"utils/generate_data_utils/#resample95similar95bin95per95bin","text":"full signature: def resample_similar_bin_per_bin( allhists, selhists, outfilename='', figname='', nresamples=1, nonnegative=True, keeppercentage=1.) comments: resample from bin-per-bin probability distributions, but only from similar looking histograms. input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram advantages: no assumptions on shape of noise, can handle systematic shifts in histograms disadvantages: bins are treated independently from each other","title":"resample_similar_bin_per_bin"},{"location":"utils/generate_data_utils/#resample95similar95fourier95noise","text":"full signature: def resample_similar_fourier_noise( allhists, selhists, outfilename='', figname='', nresamples=1, nonnegative=True, keeppercentage=1.) comments: apply fourier noise on mean histogram, where the mean is determined from a set of similar-looking histograms input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - figname: path to figure plotting examples (default: no plotting) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram advantages: most of fourier_noise_on_mean but can additionally handle shifting histograms, apart from fourier noise, also white noise can be applied. disadvantages: does not filter out odd histograms as long as enough other odd histograms look more or less similar","title":"resample_similar_fourier_noise"},{"location":"utils/generate_data_utils/#resample95similar95lico","text":"full signature: def resample_similar_lico( allhists, selhists, outfilename='', figname='', nresamples=1, nonnegative=True, keeppercentage=1.) comments: take linear combinations of similar histograms input arguments: - allhists: 2D np array (nhists,nbins) with all available histograms, used to take linear combinations - selhists: 2D np array (nhists,nbins) with selected hists used for seeding (e.g. 'good' histograms) - outfilename: path to csv file to write result to (default: no writing) - figname: path to figure plotting examples (defautl: no plotting) - nresamples: number of combinations to make per input histogram - nonnegative: boolean whether to make all final histograms nonnegative - keeppercentage: percentage (between 0. and 100.) of histograms in allhists to use per input histogram advantages: no assumptions on noise disadvantages: sensitive to outlying histograms (more than with averaging)","title":"resample_similar_lico"},{"location":"utils/generate_data_utils/#mc95sampling","text":"full signature: def mc_sampling(hists, nMC=10000 , nresamples=10) comments: resampling of a histogram using MC methods Drawing random points from a space defined by the range of the histogram in all axes. Points are \"accepted\" if the fall under the sampled histogram: f(x) - sampled distribution x_r, y_r -> randomly sampled point if y_r<=f(x_r), fill the new distribution at bin corresponding to x_r with weight: weight = (sum of input hist)/(#mc points accepted) this is equal to weight = (MC space volume)/(all MC points)","title":"mc_sampling"},{"location":"utils/hist_utils/","text":"hist utils A collection of useful basic functions for processing histograms. Functionality includes: - rebinning and normalization - moment calculation - averaging - higher-level functions preparing data for ML training, starting from a dataframe or input csv file. crophists full signature: def crophists(hists, slices=None) comments: perform cropping on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - slices: a slice object (builtin python type) or a list of two slices (for 2D) notes: - a slice can be created using the builtin python syntax 'slice(start,stop,step)', and the syntax 'list[slice]' is equivalent to 'list[start:stop:step]'. use 'None' to ignore one of the arguments for slice creation (equivalent to ':' in direct slicing) - for 1D histograms, slices can be either a slice object or a list of length 1 containing a single slice. example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but cropped according to the slices argument rebinhists full signature: def rebinhists(hists, factor=None) comments: perform rebinning on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - factor: the rebinning factor (for 1D), or a tuple of (y axis rebinning factor, x axis rebinning factor) (for 2D) note: the rebinning applied here is simple summing of bin contents, and the rebinning factors must be divisors of the respective number of bins! example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but rebinned according to the factor argument normalizehists full signature: def normalizehists(hists) comments: perform normalization on a set of histograms note: - for 1D histograms, the sum of bin contents is set equal one for each histogram - for 2D histograms, the bin contents are scaled so the maximum is 1 for each histogram - maybe later make more flexible by adding normalization stragy as argument... input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D returns: - a numpy array containing the same histograms as input but normalized averagehists full signature: def averagehists(hists, nout=None) comments: partition a set of histograms into equal parts and take the average histogram of each part input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - nout: number of partitions, i.e. number of output histograms note: nout=1 corresponds to simply taking the average of all histograms in hists. note: if nout is negative or if nout is larger than number of input histograms, the original set of histograms is returned. returns: - a numpy array of shape (nout,nbins) running_average_hists full signature: def running_average_hists(hists, window=None, weights=None) comments: replace each histogram in a collection of histograms by its running average input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - window: number of histograms to consider for the averaging if window is an integer, it is the number of previous histograms in hists used for averaging (so window=0 would correspond to no averaging) if window is a tuple, it corresponds to (nprevious,nnext), and the nprevious previous and nnext next histograms in hists are used for averaging (so window=(0,0) would correspond to no averaging) - weights: a list or numpy array containing the relative weights of the histograms in the averaging procedure. note: the weights can be any number, but they will be normalized to have unit sum. note: weights must have length nwindow+1 or nprevious+1+nnext. note: the default behaviour is a uniform array with values 1./(window+1) (or 1./(nprevious+1+nnext)) returns: - a numpy array with same shape as input but where each histogram is replaced by its running average notes: - at the edges, the weights are cropped to match the input array and renormalized - this function will crash when the length of the set of histograms is smaller than the total window length, maybe extend later (although this is not normally needed) moment full signature: def moment(bins, counts, order) comments: get n-th central moment of a histogram input arguments: - bins: a 1D or 2D np array holding the bin centers (shape (nbins) or (nhistograms,nbins)) - counts: a 2D np array containing the bin counts (shape (nhistograms,nbins)) - order: the order of the moment to calculate (0 = maximum value, 1 = mean value) returns: - an array of shape (nhistograms) holding the requested moment per histogram notes: - for now only 1D histograms are supported! histmean full signature: def histmean(bins, counts) comments: special case of moment calculation (with order=1) histrms full signature: def histrms(bins, counts) comments: special case of moment calculation histmoments full signature: def histmoments(bins, counts, orders) comments: apply moment calculation for a list of orders input arguments: - see function moment(bins, counts, order), the only difference being that orders is a list instead of a single number returns: - a numpy array of shape (nhistograms,nmoments) preparedatafromnpy full signature: def preparedatafromnpy(dataname, cropslices=None, rebinningfactor=None, donormalize=True, doplot=False) comments: read a .npy file and output the histograms input arguments: - see e.g. preparedatafromdf notes: - not yet tested for 2D histograms, but is expected to work... preparedatafromdf full signature: def preparedatafromdf(df, returnrunls=False, cropslices=None, rebinningfactor=None, donormalize=False, doplot=False) comments: prepare the data contained in a dataframe in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms preparedatafromcsv full signature: def preparedatafromcsv(dataname, returnrunls=False, cropslices=None, rebinningfactor=None, donormalize=True, doplot=False) comments: prepare the data contained in a dataframe csv file in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms","title":"hist_utils"},{"location":"utils/hist_utils/#hist-utils","text":"A collection of useful basic functions for processing histograms. Functionality includes: - rebinning and normalization - moment calculation - averaging - higher-level functions preparing data for ML training, starting from a dataframe or input csv file.","title":"hist utils"},{"location":"utils/hist_utils/#crophists","text":"full signature: def crophists(hists, slices=None) comments: perform cropping on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - slices: a slice object (builtin python type) or a list of two slices (for 2D) notes: - a slice can be created using the builtin python syntax 'slice(start,stop,step)', and the syntax 'list[slice]' is equivalent to 'list[start:stop:step]'. use 'None' to ignore one of the arguments for slice creation (equivalent to ':' in direct slicing) - for 1D histograms, slices can be either a slice object or a list of length 1 containing a single slice. example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but cropped according to the slices argument","title":"crophists"},{"location":"utils/hist_utils/#rebinhists","text":"full signature: def rebinhists(hists, factor=None) comments: perform rebinning on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - factor: the rebinning factor (for 1D), or a tuple of (y axis rebinning factor, x axis rebinning factor) (for 2D) note: the rebinning applied here is simple summing of bin contents, and the rebinning factors must be divisors of the respective number of bins! example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but rebinned according to the factor argument","title":"rebinhists"},{"location":"utils/hist_utils/#normalizehists","text":"full signature: def normalizehists(hists) comments: perform normalization on a set of histograms note: - for 1D histograms, the sum of bin contents is set equal one for each histogram - for 2D histograms, the bin contents are scaled so the maximum is 1 for each histogram - maybe later make more flexible by adding normalization stragy as argument... input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D returns: - a numpy array containing the same histograms as input but normalized","title":"normalizehists"},{"location":"utils/hist_utils/#averagehists","text":"full signature: def averagehists(hists, nout=None) comments: partition a set of histograms into equal parts and take the average histogram of each part input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - nout: number of partitions, i.e. number of output histograms note: nout=1 corresponds to simply taking the average of all histograms in hists. note: if nout is negative or if nout is larger than number of input histograms, the original set of histograms is returned. returns: - a numpy array of shape (nout,nbins)","title":"averagehists"},{"location":"utils/hist_utils/#running95average95hists","text":"full signature: def running_average_hists(hists, window=None, weights=None) comments: replace each histogram in a collection of histograms by its running average input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - window: number of histograms to consider for the averaging if window is an integer, it is the number of previous histograms in hists used for averaging (so window=0 would correspond to no averaging) if window is a tuple, it corresponds to (nprevious,nnext), and the nprevious previous and nnext next histograms in hists are used for averaging (so window=(0,0) would correspond to no averaging) - weights: a list or numpy array containing the relative weights of the histograms in the averaging procedure. note: the weights can be any number, but they will be normalized to have unit sum. note: weights must have length nwindow+1 or nprevious+1+nnext. note: the default behaviour is a uniform array with values 1./(window+1) (or 1./(nprevious+1+nnext)) returns: - a numpy array with same shape as input but where each histogram is replaced by its running average notes: - at the edges, the weights are cropped to match the input array and renormalized - this function will crash when the length of the set of histograms is smaller than the total window length, maybe extend later (although this is not normally needed)","title":"running_average_hists"},{"location":"utils/hist_utils/#moment","text":"full signature: def moment(bins, counts, order) comments: get n-th central moment of a histogram input arguments: - bins: a 1D or 2D np array holding the bin centers (shape (nbins) or (nhistograms,nbins)) - counts: a 2D np array containing the bin counts (shape (nhistograms,nbins)) - order: the order of the moment to calculate (0 = maximum value, 1 = mean value) returns: - an array of shape (nhistograms) holding the requested moment per histogram notes: - for now only 1D histograms are supported!","title":"moment"},{"location":"utils/hist_utils/#histmean","text":"full signature: def histmean(bins, counts) comments: special case of moment calculation (with order=1)","title":"histmean"},{"location":"utils/hist_utils/#histrms","text":"full signature: def histrms(bins, counts) comments: special case of moment calculation","title":"histrms"},{"location":"utils/hist_utils/#histmoments","text":"full signature: def histmoments(bins, counts, orders) comments: apply moment calculation for a list of orders input arguments: - see function moment(bins, counts, order), the only difference being that orders is a list instead of a single number returns: - a numpy array of shape (nhistograms,nmoments)","title":"histmoments"},{"location":"utils/hist_utils/#preparedatafromnpy","text":"full signature: def preparedatafromnpy(dataname, cropslices=None, rebinningfactor=None, donormalize=True, doplot=False) comments: read a .npy file and output the histograms input arguments: - see e.g. preparedatafromdf notes: - not yet tested for 2D histograms, but is expected to work...","title":"preparedatafromnpy"},{"location":"utils/hist_utils/#preparedatafromdf","text":"full signature: def preparedatafromdf(df, returnrunls=False, cropslices=None, rebinningfactor=None, donormalize=False, doplot=False) comments: prepare the data contained in a dataframe in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms","title":"preparedatafromdf"},{"location":"utils/hist_utils/#preparedatafromcsv","text":"full signature: def preparedatafromcsv(dataname, returnrunls=False, cropslices=None, rebinningfactor=None, donormalize=True, doplot=False) comments: prepare the data contained in a dataframe csv file in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms","title":"preparedatafromcsv"},{"location":"utils/json_utils/","text":"json utils A collection of useful basic functions for manipulating json files. Functionality includes: - reading and writing json files for given sets of run numbers and lumisection numbers - checking if a given run number, lumisection number or combination is present in a given json file Note that the json files are always assumed to contain the following structure: - dict - run number (in string format) - list - list of two elements - starting lumisection number, ending lumisection number Example: { \"294927\": [ [ 55,85 ], [ 95,105] ] } There is one exception to this rule: instead of [ start, stop ], the lumisection list can also be [ -1 ], which is short for all lumisections within that run. loadjson full signature: def loadjson( jsonfile ) comments: load the content of a json file into a python object input arguments: - jsonfile: the name (or full path if needed) to the json file to be read output: - an dict object as specified in the note below note: the json file is supposed to contain an object like this example: { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } although no explicit checking is done in this function, objects that don't have this structure will probably lead to errors further in the code writejson full signature: def writejson( jsondict, outputfile, overwrite=False ) comments: inverse function of loadjson input arguments - jsondict: dict object to be written to a json file - outputfile: output file to be written, extension '.json' will be appended automatically - overwrite: boolean whether to overwrite outputfile if it exists (default: throw exception) injson_single full signature: def injson_single( run, lumi, jsondict ) comments: helper function for injson, only for internal use input arguments: - run and lumi are integers - jsondict is an object loaded from a json file output: - boolean whether the run/lumi combination is in the json dict injson full signature: def injson( run, lumi, jsonfile=None, jsondict=None ) comments: find if a run and lumi combination is in a given json file input arguments: - run and lumi: integers or (equally long) arrays of integers - jsonfile: a path to a json file - jsondict: a dict loaded from a json file note: either jsonfile or jsondict must not be None! output: boolean or array of booleans (depending on run and lumi) getjsondir full signature: def getjsondir() comments: internal helper function returning the path to where json files are stored isgolden full signature: def isgolden(run, lumi) comments: find if a run and lumi combination is in the golden json file input arguments: - run and lumi: either integers or (equally long) arrays of integers isdcson full signature: def isdcson(run, lumi) comments: find if a run and lumi combination is in DCS-only json file input arguments: - run and lumi: either integers or (equally long) arrays of integers plainlist_to_rangelist full signature: def plainlist_to_rangelist( plainlist ) comments: helper function for tuplelist_to_jsondict, only for internal use input arguments: - plainlist: a list of integers in increasing order, must have length >= 2 output: - a list lists representing ranges example: [1,2,3,5,6] -> [ [1,3], [5,6] ] rangelist_to_plainlist full signature: def rangelist_to_plainlist( rangelist ) comments: inverse function of plainlist_to_rangelist, for internal use only tuplelist_to_jsondict full signature: def tuplelist_to_jsondict( tuplelist ) comments: convert a list of tuples of format (run number, [lumisection numbers]) to json dict jsondict_to_tuplelist full signature: def jsondict_to_tuplelist( jsondict ) comments: inverse function of tuplelist_to_jsondict get_lcs full signature: def get_lcs( jsonlist ) comments: return a jsondict object that is the largest common subset (LCS) between the jsondict objects in jsonlist input arguments: - jsonlist: a list of dicts in the conventional json format, so each element in jsonlist must be e.g. { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } remark: this is probably not the most efficient implementation, open for improvement...","title":"json_utils"},{"location":"utils/json_utils/#json-utils","text":"A collection of useful basic functions for manipulating json files. Functionality includes: - reading and writing json files for given sets of run numbers and lumisection numbers - checking if a given run number, lumisection number or combination is present in a given json file Note that the json files are always assumed to contain the following structure: - dict - run number (in string format) - list - list of two elements - starting lumisection number, ending lumisection number Example: { \"294927\": [ [ 55,85 ], [ 95,105] ] } There is one exception to this rule: instead of [ start, stop ], the lumisection list can also be [ -1 ], which is short for all lumisections within that run.","title":"json utils"},{"location":"utils/json_utils/#loadjson","text":"full signature: def loadjson( jsonfile ) comments: load the content of a json file into a python object input arguments: - jsonfile: the name (or full path if needed) to the json file to be read output: - an dict object as specified in the note below note: the json file is supposed to contain an object like this example: { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } although no explicit checking is done in this function, objects that don't have this structure will probably lead to errors further in the code","title":"loadjson"},{"location":"utils/json_utils/#writejson","text":"full signature: def writejson( jsondict, outputfile, overwrite=False ) comments: inverse function of loadjson input arguments - jsondict: dict object to be written to a json file - outputfile: output file to be written, extension '.json' will be appended automatically - overwrite: boolean whether to overwrite outputfile if it exists (default: throw exception)","title":"writejson"},{"location":"utils/json_utils/#injson95single","text":"full signature: def injson_single( run, lumi, jsondict ) comments: helper function for injson, only for internal use input arguments: - run and lumi are integers - jsondict is an object loaded from a json file output: - boolean whether the run/lumi combination is in the json dict","title":"injson_single"},{"location":"utils/json_utils/#injson","text":"full signature: def injson( run, lumi, jsonfile=None, jsondict=None ) comments: find if a run and lumi combination is in a given json file input arguments: - run and lumi: integers or (equally long) arrays of integers - jsonfile: a path to a json file - jsondict: a dict loaded from a json file note: either jsonfile or jsondict must not be None! output: boolean or array of booleans (depending on run and lumi)","title":"injson"},{"location":"utils/json_utils/#getjsondir","text":"full signature: def getjsondir() comments: internal helper function returning the path to where json files are stored","title":"getjsondir"},{"location":"utils/json_utils/#isgolden","text":"full signature: def isgolden(run, lumi) comments: find if a run and lumi combination is in the golden json file input arguments: - run and lumi: either integers or (equally long) arrays of integers","title":"isgolden"},{"location":"utils/json_utils/#isdcson","text":"full signature: def isdcson(run, lumi) comments: find if a run and lumi combination is in DCS-only json file input arguments: - run and lumi: either integers or (equally long) arrays of integers","title":"isdcson"},{"location":"utils/json_utils/#plainlist95to95rangelist","text":"full signature: def plainlist_to_rangelist( plainlist ) comments: helper function for tuplelist_to_jsondict, only for internal use input arguments: - plainlist: a list of integers in increasing order, must have length >= 2 output: - a list lists representing ranges example: [1,2,3,5,6] -> [ [1,3], [5,6] ]","title":"plainlist_to_rangelist"},{"location":"utils/json_utils/#rangelist95to95plainlist","text":"full signature: def rangelist_to_plainlist( rangelist ) comments: inverse function of plainlist_to_rangelist, for internal use only","title":"rangelist_to_plainlist"},{"location":"utils/json_utils/#tuplelist95to95jsondict","text":"full signature: def tuplelist_to_jsondict( tuplelist ) comments: convert a list of tuples of format (run number, [lumisection numbers]) to json dict","title":"tuplelist_to_jsondict"},{"location":"utils/json_utils/#jsondict95to95tuplelist","text":"full signature: def jsondict_to_tuplelist( jsondict ) comments: inverse function of tuplelist_to_jsondict","title":"jsondict_to_tuplelist"},{"location":"utils/json_utils/#get95lcs","text":"full signature: def get_lcs( jsonlist ) comments: return a jsondict object that is the largest common subset (LCS) between the jsondict objects in jsonlist input arguments: - jsonlist: a list of dicts in the conventional json format, so each element in jsonlist must be e.g. { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } remark: this is probably not the most efficient implementation, open for improvement...","title":"get_lcs"},{"location":"utils/mask_utils/","text":"mask utils Utilities for working with HistStruct masks Mostly meant for internal use. get_combined_name full signature: def get_combined_name( masklist ) comments: concatenate all the masknames in masklist to a combined name input arguments: - masklist: list of strings output: string with contatenated name","title":"mask_utils"},{"location":"utils/mask_utils/#mask-utils","text":"Utilities for working with HistStruct masks Mostly meant for internal use.","title":"mask utils"},{"location":"utils/mask_utils/#get95combined95name","text":"full signature: def get_combined_name( masklist ) comments: concatenate all the masknames in masklist to a combined name input arguments: - masklist: list of strings output: string with contatenated name","title":"get_combined_name"},{"location":"utils/plot_utils/","text":"plot utils A collection of useful basic functions for plotting. make_legend_opaque full signature: def make_legend_opaque( leg ) comments: set the transparency of all entries in a legend to zero add_text full signature: def add_text( ax, text, pos, fontsize=10, background_facecolor=None, background_alpha=None, background_edgecolor=None ) comments: add text to an axis at a specified position (in relative figure coordinates) input arguments: - ax: matplotlib axis object - text: string, can contain latex syntax such as /textbf{} and /textit{} - pos: tuple with relative x- and y-axis coordinates of bottom left corner add_cms_label full signature: def add_cms_label( ax, pos=(0.1,0.9), extratext=None, **kwargs ) comments: add the CMS label and extra text (e.g. 'Preliminary') to a plot special case of add_text, for convenience make_text_latex_safe full signature: def make_text_latex_safe( text ) comments: make a string safe to process with matplotlib's latex parser in case no tex parsing is wanted (e.g. escape underscores) to be extended when the need arises! plot_hists full signature: def plot_hists(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, xaxtitle=None, yaxtitle=None, bkgcolor=None, bkgcmap='spring', bkgrange=None, bkgtitle=None) comments: plot some histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing colors (in string format), of length nhistograms note: it can also be a single string representing a color (in pyplot), then all histograms will take this color - labellist is a list or array containing labels for in legend, of length nhistograms - xlims is a tuple of min and max for the x-axis labels, defaults to (-0.5,nbins-0.5) - title, xaxtitle, yaxtitle: strings for histogram title, x-axis title and y-axis title respectively - bkgcolor: 1D array representing background color for the plot (color axis will be scaled between min and max in bkgcolor) note: if bkgcolor does not have the same length as the x-axis, it will be compressed or stretched to fit the axis, but this might be meaningless, depending on what you are trying to visualize! - bkgmap: name of valid pyplot color map for plotting the background color output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it plot_hists_multi full signature: def plot_hists_multi(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, xaxtitle=None, yaxtitle=None) comments: plot many histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing numbers to be mapped to colors - labellist is a list or array containing labels for in legend output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it plot_hist_2d full signature: def plot_hist_2d(hist, fig=None, ax=None, title=None, xaxtitle=None, yaxtitle=None, caxrange=None) comments: plot a 2D histogram - hist is a 2D numpy array of shape (nxbins, nybins) notes: - if the histogram contains only nonnegative values, values below 1e-12 will not be plotted (i.e. they will be shown as white spots in the plot) to discriminate zero from small but nonzero - if the histogram contains negative values, the color axis will be symmetrized around zero plot_hists_2d full signature: def plot_hists_2d(hists, ncols=4, title=None, subtitles=None, xaxtitle=None, yaxtitle=None, caxrange=None) comments: plot multiple 2D histograms next to each other - hists: list of 2D numpy arrays of shape (nxbins,nybins), or an equivalent 3D numpy array - ncols: number of columns to use plot_hists_2d_gif full signature: def plot_hists_2d_gif(hists, titles=None, xaxtitle=None, yaxtitle=None, duration=0.3, figname='temp_gif.gif') comments: (no valid documentation found) plot_hists_from_df full signature: def plot_hists_from_df(df, histtype, nhists) comments: plot a number of histograms in a dataframe - df is the dataframe from which to plot - histtype is the name of the histogram type (e.g. 'chargeInner_PXLayer_1') - nhists is the number of histograms to plot plot_sets full signature: def plot_sets(setlist, fig=None, ax=None, colorlist=[], labellist=[], transparencylist=[], title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, xlims=(-0.5,-1), yaxtitle=None, yaxtitlesize=None, ymaxfactor=None, legendsize=None, opaque_legend=False) comments: plot multiple sets of histograms to compare the shapes - setlist is a list of 2D numpy arrays containing histograms - fig and ax: a pyplot figure and axis object (if one of both is none a new figure is created) - title is a string that will be used as the title for the ax object other parameters are lists of which each element applies to one list of histograms plot_anomalous full signature: def plot_anomalous(histlist, ls, highlight=-1, hrange=-1) comments: plot a range of histograms and highlight one of them input arguments: - histlist and ls: a list of histograms and corresponding lumisection numbers - highlight: the lumisection number of the histogram to highlight - hrange: the number of histograms before and after lsnumber to plot (default: whole run) plot_moments full signature: def plot_moments(moments, ls, dims=(0,1), fig=None, ax=None, markersize=10) comments: plot the moments of a set of histograms input arguments: - moments: a numpy array of shape (nhists,nmoments) - dims: a tuple of two or three values between 0 and nmoments-1 plot_distance full signature: def plot_distance(dists, ls=None, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='distance metric') comments: (no valid documentation found) plot_loss full signature: def plot_loss(data, xlims=None, title=None, xaxtitle='epoch', yaxtitle='loss', doshow=True) comments: plot the training and validation loss data is the object returned by the .fit method when called upon a keras model e.g. history = <your autoencoder>.fit(<training params>) plot_loss(history,'a title') plot_mse full signature: def plot_mse(mse, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='mse') comments: plot the mse's and return the mean and std input args: - mse is a 1D numpy array of mse scores - doplot: boolean whether to make a plot or simply return mean and std - rmlargest: fraction of largest mse's to remove (to avoid being too sensitive to outliers) plot_score_dist full signature: def plot_score_dist( scores, labels, fig=None, ax=None, nbins=20, normalize=False, siglabel='signal', sigcolor='g', bcklabel='background', bckcolor='r', title=None, xaxtitle=None, yaxtitle=None, doshow=True) comments: make a plot showing the distributions of the output scores for signal and background plot_metric full signature: def plot_metric( wprange, metric, label=None, color=None, sig_eff=None, sig_label=None, sig_color=None, bck_eff=None, bck_label=None, bck_color=None, title=None, xaxtitle='working point', yaxlog=False, ymaxfactor=1.3, yaxtitle='metric' ) comments: plot a metric based on signal and background efficiencies. along with the metric, the actual signal and background efficiencies can be plotted as well. input arguments: - wprange, metric: equally long 1D-numpy arrays, x- and y-data respectively - label: label for the metric to put in the legend - color: color for the metric (default: blue) - sig_eff: 1D-numpy array of signal efficiencies corresponding to wprange - sig_label: label for sig_eff in the legend - color: color for sig_eff (default: green) - bck_eff, bck_label, bck_color: same as for signal - title, xaxtitle and yaxtitle: titles for the plot and axes - yaxlog: boolean whether to put y axis in log scale - ymaxfactor: factor to add extra space on the top of the plot (for the legend) plot_fit_2d full signature: def plot_fit_2d( points, fitfunc=None, logprob=False, clipprob=False, onlycontour=False, xlims=5, ylims=5, onlypositive=False, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, title=None, titlesize=None, caxtitle=None, caxtitlesize=None, transparency=1 ) comments: make a scatter plot of a 2D point cloud with fitted contour input arguments: - points: a numpy array of shape (npoints,ndims) - fitfunc: an object of type CloudFitter (see src/cloudfitters) or any other object that implements a pdf(points) method - logprob: boolean whether to plot log probability or normal probability - clipprob: boolean whether to replace +- inf values by (non-inf) max and min - onlycontour: a boolean whether to draw only the fit or include the data points - xlims and ylims: tuples of (low,high) note: can be an integer, in which case the range will be determined automatically from the formula low = mean-xlims*std, high = mean+xlims*std, where mean and std are determined from the points array. - onlypositive: overrides previous argument to set lower bound of plotting range at 0 in both dimensions. - xaxtitle and yaxtitle: titles for axes. plot_fit_2d_clusters full signature: def plot_fit_2d_clusters( points, clusters, labels, colors, **kwargs ) comments: make a scatter plot of a fitted contour with point clouds superimposed input arguments: - points: numpy arrays of shape (npoints,ndims), usually the points to which the fit was done note: only used to determine plotting range, these points are not plotted! - clusters: list of numpy arrays of shape (npoints,ndims), clouds of points to plot - labels: list with legend entries (must be same length as clusters) - colors: list with colors (must be same length as clusters) - kwargs: passed down to plot_fit_2d note: onlycontour is set automatically and should not be in kwargs","title":"plot_utils"},{"location":"utils/plot_utils/#plot-utils","text":"A collection of useful basic functions for plotting.","title":"plot utils"},{"location":"utils/plot_utils/#make95legend95opaque","text":"full signature: def make_legend_opaque( leg ) comments: set the transparency of all entries in a legend to zero","title":"make_legend_opaque"},{"location":"utils/plot_utils/#add95text","text":"full signature: def add_text( ax, text, pos, fontsize=10, background_facecolor=None, background_alpha=None, background_edgecolor=None ) comments: add text to an axis at a specified position (in relative figure coordinates) input arguments: - ax: matplotlib axis object - text: string, can contain latex syntax such as /textbf{} and /textit{} - pos: tuple with relative x- and y-axis coordinates of bottom left corner","title":"add_text"},{"location":"utils/plot_utils/#add95cms95label","text":"full signature: def add_cms_label( ax, pos=(0.1,0.9), extratext=None, **kwargs ) comments: add the CMS label and extra text (e.g. 'Preliminary') to a plot special case of add_text, for convenience","title":"add_cms_label"},{"location":"utils/plot_utils/#make95text95latex95safe","text":"full signature: def make_text_latex_safe( text ) comments: make a string safe to process with matplotlib's latex parser in case no tex parsing is wanted (e.g. escape underscores) to be extended when the need arises!","title":"make_text_latex_safe"},{"location":"utils/plot_utils/#plot95hists","text":"full signature: def plot_hists(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, xaxtitle=None, yaxtitle=None, bkgcolor=None, bkgcmap='spring', bkgrange=None, bkgtitle=None) comments: plot some histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing colors (in string format), of length nhistograms note: it can also be a single string representing a color (in pyplot), then all histograms will take this color - labellist is a list or array containing labels for in legend, of length nhistograms - xlims is a tuple of min and max for the x-axis labels, defaults to (-0.5,nbins-0.5) - title, xaxtitle, yaxtitle: strings for histogram title, x-axis title and y-axis title respectively - bkgcolor: 1D array representing background color for the plot (color axis will be scaled between min and max in bkgcolor) note: if bkgcolor does not have the same length as the x-axis, it will be compressed or stretched to fit the axis, but this might be meaningless, depending on what you are trying to visualize! - bkgmap: name of valid pyplot color map for plotting the background color output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it","title":"plot_hists"},{"location":"utils/plot_utils/#plot95hists95multi","text":"full signature: def plot_hists_multi(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, xaxtitle=None, yaxtitle=None) comments: plot many histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing numbers to be mapped to colors - labellist is a list or array containing labels for in legend output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it","title":"plot_hists_multi"},{"location":"utils/plot_utils/#plot95hist952d","text":"full signature: def plot_hist_2d(hist, fig=None, ax=None, title=None, xaxtitle=None, yaxtitle=None, caxrange=None) comments: plot a 2D histogram - hist is a 2D numpy array of shape (nxbins, nybins) notes: - if the histogram contains only nonnegative values, values below 1e-12 will not be plotted (i.e. they will be shown as white spots in the plot) to discriminate zero from small but nonzero - if the histogram contains negative values, the color axis will be symmetrized around zero","title":"plot_hist_2d"},{"location":"utils/plot_utils/#plot95hists952d","text":"full signature: def plot_hists_2d(hists, ncols=4, title=None, subtitles=None, xaxtitle=None, yaxtitle=None, caxrange=None) comments: plot multiple 2D histograms next to each other - hists: list of 2D numpy arrays of shape (nxbins,nybins), or an equivalent 3D numpy array - ncols: number of columns to use","title":"plot_hists_2d"},{"location":"utils/plot_utils/#plot95hists952d95gif","text":"full signature: def plot_hists_2d_gif(hists, titles=None, xaxtitle=None, yaxtitle=None, duration=0.3, figname='temp_gif.gif') comments: (no valid documentation found)","title":"plot_hists_2d_gif"},{"location":"utils/plot_utils/#plot95hists95from95df","text":"full signature: def plot_hists_from_df(df, histtype, nhists) comments: plot a number of histograms in a dataframe - df is the dataframe from which to plot - histtype is the name of the histogram type (e.g. 'chargeInner_PXLayer_1') - nhists is the number of histograms to plot","title":"plot_hists_from_df"},{"location":"utils/plot_utils/#plot95sets","text":"full signature: def plot_sets(setlist, fig=None, ax=None, colorlist=[], labellist=[], transparencylist=[], title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, xlims=(-0.5,-1), yaxtitle=None, yaxtitlesize=None, ymaxfactor=None, legendsize=None, opaque_legend=False) comments: plot multiple sets of histograms to compare the shapes - setlist is a list of 2D numpy arrays containing histograms - fig and ax: a pyplot figure and axis object (if one of both is none a new figure is created) - title is a string that will be used as the title for the ax object other parameters are lists of which each element applies to one list of histograms","title":"plot_sets"},{"location":"utils/plot_utils/#plot95anomalous","text":"full signature: def plot_anomalous(histlist, ls, highlight=-1, hrange=-1) comments: plot a range of histograms and highlight one of them input arguments: - histlist and ls: a list of histograms and corresponding lumisection numbers - highlight: the lumisection number of the histogram to highlight - hrange: the number of histograms before and after lsnumber to plot (default: whole run)","title":"plot_anomalous"},{"location":"utils/plot_utils/#plot95moments","text":"full signature: def plot_moments(moments, ls, dims=(0,1), fig=None, ax=None, markersize=10) comments: plot the moments of a set of histograms input arguments: - moments: a numpy array of shape (nhists,nmoments) - dims: a tuple of two or three values between 0 and nmoments-1","title":"plot_moments"},{"location":"utils/plot_utils/#plot95distance","text":"full signature: def plot_distance(dists, ls=None, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='distance metric') comments: (no valid documentation found)","title":"plot_distance"},{"location":"utils/plot_utils/#plot95loss","text":"full signature: def plot_loss(data, xlims=None, title=None, xaxtitle='epoch', yaxtitle='loss', doshow=True) comments: plot the training and validation loss data is the object returned by the .fit method when called upon a keras model e.g. history = <your autoencoder>.fit(<training params>) plot_loss(history,'a title')","title":"plot_loss"},{"location":"utils/plot_utils/#plot95mse","text":"full signature: def plot_mse(mse, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='mse') comments: plot the mse's and return the mean and std input args: - mse is a 1D numpy array of mse scores - doplot: boolean whether to make a plot or simply return mean and std - rmlargest: fraction of largest mse's to remove (to avoid being too sensitive to outliers)","title":"plot_mse"},{"location":"utils/plot_utils/#plot95score95dist","text":"full signature: def plot_score_dist( scores, labels, fig=None, ax=None, nbins=20, normalize=False, siglabel='signal', sigcolor='g', bcklabel='background', bckcolor='r', title=None, xaxtitle=None, yaxtitle=None, doshow=True) comments: make a plot showing the distributions of the output scores for signal and background","title":"plot_score_dist"},{"location":"utils/plot_utils/#plot95metric","text":"full signature: def plot_metric( wprange, metric, label=None, color=None, sig_eff=None, sig_label=None, sig_color=None, bck_eff=None, bck_label=None, bck_color=None, title=None, xaxtitle='working point', yaxlog=False, ymaxfactor=1.3, yaxtitle='metric' ) comments: plot a metric based on signal and background efficiencies. along with the metric, the actual signal and background efficiencies can be plotted as well. input arguments: - wprange, metric: equally long 1D-numpy arrays, x- and y-data respectively - label: label for the metric to put in the legend - color: color for the metric (default: blue) - sig_eff: 1D-numpy array of signal efficiencies corresponding to wprange - sig_label: label for sig_eff in the legend - color: color for sig_eff (default: green) - bck_eff, bck_label, bck_color: same as for signal - title, xaxtitle and yaxtitle: titles for the plot and axes - yaxlog: boolean whether to put y axis in log scale - ymaxfactor: factor to add extra space on the top of the plot (for the legend)","title":"plot_metric"},{"location":"utils/plot_utils/#plot95fit952d","text":"full signature: def plot_fit_2d( points, fitfunc=None, logprob=False, clipprob=False, onlycontour=False, xlims=5, ylims=5, onlypositive=False, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, title=None, titlesize=None, caxtitle=None, caxtitlesize=None, transparency=1 ) comments: make a scatter plot of a 2D point cloud with fitted contour input arguments: - points: a numpy array of shape (npoints,ndims) - fitfunc: an object of type CloudFitter (see src/cloudfitters) or any other object that implements a pdf(points) method - logprob: boolean whether to plot log probability or normal probability - clipprob: boolean whether to replace +- inf values by (non-inf) max and min - onlycontour: a boolean whether to draw only the fit or include the data points - xlims and ylims: tuples of (low,high) note: can be an integer, in which case the range will be determined automatically from the formula low = mean-xlims*std, high = mean+xlims*std, where mean and std are determined from the points array. - onlypositive: overrides previous argument to set lower bound of plotting range at 0 in both dimensions. - xaxtitle and yaxtitle: titles for axes.","title":"plot_fit_2d"},{"location":"utils/plot_utils/#plot95fit952d95clusters","text":"full signature: def plot_fit_2d_clusters( points, clusters, labels, colors, **kwargs ) comments: make a scatter plot of a fitted contour with point clouds superimposed input arguments: - points: numpy arrays of shape (npoints,ndims), usually the points to which the fit was done note: only used to determine plotting range, these points are not plotted! - clusters: list of numpy arrays of shape (npoints,ndims), clouds of points to plot - labels: list with legend entries (must be same length as clusters) - colors: list with colors (must be same length as clusters) - kwargs: passed down to plot_fit_2d note: onlycontour is set automatically and should not be in kwargs","title":"plot_fit_2d_clusters"},{"location":"utils/refruns_utils/","text":"refruns utils Tools for retrieving a reference run for a given run Preliminary implementation, based on a json file generated by the Tracker DQM group. Retrieved from here . Perhaps modify code later to fetch the up-to-date version at runtime instead of having to download a new version. Maybe also using an API to retrieve only the requested run instead of loading the entire file into memory. get_reference_run full signature: def get_reference_run( runnb, jsonlist=None, jsonfile='json_allRunsRefRuns.json' ) comments: get the reference run for a given run number input arguments: - runnb: integer representing a run number. - jsonlist: list matching run numbers to reference run numbers. note: the list is supposed to contain dicts with keys 'run_number' and 'reference_run_number', this convention is based on the json file provided by the tracker group. note: if jsonlist is None, jsonfile (see below) will be opened and a jsonlist read from it. - jsonfile: path to json file matching run numbers to reference run numbers. note: the json file must contain a list of dicts with keys 'run_number' and 'reference_run_number', as explained above. note: ignored if jsonlist is not None. output: integer representing the reference run number for the given run. if the given run is not in the json, -1 is returned.","title":"refruns_utils"},{"location":"utils/refruns_utils/#refruns-utils","text":"Tools for retrieving a reference run for a given run Preliminary implementation, based on a json file generated by the Tracker DQM group. Retrieved from here . Perhaps modify code later to fetch the up-to-date version at runtime instead of having to download a new version. Maybe also using an API to retrieve only the requested run instead of loading the entire file into memory.","title":"refruns utils"},{"location":"utils/refruns_utils/#get95reference95run","text":"full signature: def get_reference_run( runnb, jsonlist=None, jsonfile='json_allRunsRefRuns.json' ) comments: get the reference run for a given run number input arguments: - runnb: integer representing a run number. - jsonlist: list matching run numbers to reference run numbers. note: the list is supposed to contain dicts with keys 'run_number' and 'reference_run_number', this convention is based on the json file provided by the tracker group. note: if jsonlist is None, jsonfile (see below) will be opened and a jsonlist read from it. - jsonfile: path to json file matching run numbers to reference run numbers. note: the json file must contain a list of dicts with keys 'run_number' and 'reference_run_number', as explained above. note: ignored if jsonlist is not None. output: integer representing the reference run number for the given run. if the given run is not in the json, -1 is returned.","title":"get_reference_run"}]}